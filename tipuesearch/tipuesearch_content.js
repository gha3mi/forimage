var tipuesearch = {"pages":[{"title":" ForImage ","text":"ForImage ForImage : A Fortran library for PNM file processing and image editing. PNM File Support fpm dependency How to run examples API documentation Contributing PNM File Support ForImage offers comprehensive support for PNM files, including creation, importing, and exporting capabilities. It seamlessly handles formats such as PBM , PGM , and PPM in both ASCII and binary representations. Available features include: Original Negative Brighten Swap Channels Remove Channels Greyscale Rotate Flip Horizontal Flip Vertical Crop Resize fpm dependency If you want to use ForImage as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] forimage = { git = \"https://github.com/gha3mi/forimage.git\" } How to run demo Clone the repository: You can clone the ForImage repository from GitHub using the following command: git clone https://github.com/gha3mi/forimage.git cd forimage fpm run --example demo API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForImage using ford run the following\ncommand: ford ford.yml Contributing Contributions to ForImage are welcome!\nIf you find any issues or would like to suggest improvements, please open an issue. Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"format_lut – ForImage ","text":"type, public :: format_lut Components Type Visibility Attributes Name Initial integer, public :: num_colors integer, public :: dim_colors integer, public, dimension(:,:), allocatable :: colors Type-Bound Procedures procedure, public :: allocate_colors private pure elemental subroutine allocate_colors (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this procedure, public :: set private pure subroutine set (this, num_colors, dim_colors, colors) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this integer, intent(in) :: num_colors integer, intent(in) :: dim_colors integer, intent(in), dimension(:,:) :: colors procedure, public :: set_num_colors private pure elemental subroutine set_num_colors (this, num_colors) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this integer, intent(in) :: num_colors procedure, public :: get_num_colors private pure elemental function get_num_colors (this) result(num_colors) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(in) :: this Return Value integer procedure, public :: set_dim_colors private pure elemental subroutine set_dim_colors (this, dim_colors) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this integer, intent(in) :: dim_colors procedure, public :: get_dim_colors private pure elemental function get_dim_colors (this) result(dim_colors) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(in) :: this Return Value integer procedure, public :: set_colors private pure subroutine set_colors (this, colors) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this integer, intent(in), dimension(:,:) :: colors procedure, public :: get_colors private pure function get_colors (this) result(colors) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(in) :: this Return Value integer, dimension(:,:), allocatable procedure, public :: export private impure subroutine export (this, file_name) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this character(len=*), intent(in) :: file_name procedure, public :: import private impure subroutine import (this, file_name, dim_colors) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this character(len=*), intent(in) :: file_name integer, intent(in) :: dim_colors procedure, public :: finalize => deallocate_lut private pure elemental subroutine deallocate_lut (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this Source Code type format_lut integer :: num_colors integer :: dim_colors integer , dimension (:,:), allocatable :: colors contains procedure :: allocate_colors procedure :: set procedure :: set_num_colors procedure :: get_num_colors procedure :: set_dim_colors procedure :: get_dim_colors procedure :: set_colors procedure :: get_colors procedure :: export procedure :: import procedure :: finalize => deallocate_lut end type format_lut","tags":"","loc":"type/format_lut.html"},{"title":"format_pnm – ForImage ","text":"type, public :: format_pnm Components Type Visibility Attributes Name Initial character(len=2), private :: magic_number integer, private :: width integer, private :: height character(len=:), private, allocatable :: comment integer, private :: max_color integer(kind=ik), public, dimension(:,:), allocatable :: pixels character(len=3), private :: file_format character(len=6), private :: encoding Type-Bound Procedures procedure, public :: set_format private pure elemental subroutine set_format (this, encoding) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: encoding procedure, private :: set_file_format private pure elemental subroutine set_file_format (this, file_format) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=3), intent(in) :: file_format procedure, private :: set_magicnumber private pure elemental subroutine set_magicnumber (this, magic_number) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: magic_number procedure, private :: set_width private pure elemental subroutine set_width (this, width) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: width procedure, private :: set_height private pure elemental subroutine set_height (this, height) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: height procedure, private :: set_comment private pure elemental subroutine set_comment (this, comment) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: comment procedure, private :: set_max_color private pure elemental subroutine set_max_color (this, max_color) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: max_color procedure, private :: set_header private pure elemental subroutine set_header (this, magic_number, width, height, comment, max_color) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: magic_number integer, intent(in) :: width integer, intent(in) :: height character(len=*), intent(in) :: comment integer, intent(in), optional :: max_color procedure, private :: allocate_pixels private pure elemental subroutine allocate_pixels (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this procedure, private :: check_pixel_range private pure subroutine check_pixel_range (this, pixels) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:,:) :: pixels procedure, private :: set_pixels private pure subroutine set_pixels (this, pixels) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:,:) :: pixels procedure, public :: set_pnm private pure subroutine set_pnm (this, encoding, file_format, width, height, max_color, comment, pixels) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: encoding character(len=3), intent(in) :: file_format integer, intent(in) :: width integer, intent(in) :: height integer, intent(in), optional :: max_color character(len=*), intent(in) :: comment integer(kind=ik), intent(in), dimension(:,:) :: pixels procedure, public :: print_info private impure elemental subroutine print_info (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(in) :: this procedure, public :: import_pnm private impure subroutine import_pnm (this, file_name, file_format, encoding) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: file_name character(len=3), intent(in) :: file_format character(len=*), intent(in) :: encoding procedure, public :: export_pnm private impure subroutine export_pnm (this, file_name, encoding) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: file_name character(len=*), intent(in), optional :: encoding procedure, public :: finalize => deallocate_pnm private pure elemental subroutine deallocate_pnm (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this procedure, public :: negative private pure elemental subroutine negative (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this procedure, public :: brighten private pure elemental subroutine brighten (this, factor) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: factor procedure, public :: swap_channels private pure elemental subroutine swap_channels (this, swap) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: swap procedure, public :: remove_channels private pure elemental subroutine remove_channels (this, remove_r, remove_g, remove_b) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this logical, intent(in), optional :: remove_r logical, intent(in), optional :: remove_g logical, intent(in), optional :: remove_b procedure, public :: greyscale private pure elemental subroutine greyscale (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this procedure, public :: rotate private pure elemental subroutine rotate (this, angle) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: angle procedure, public :: flip_horizontal private pure elemental subroutine flip_horizontal (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this procedure, public :: flip_vertical private pure elemental subroutine flip_vertical (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this procedure, public :: crop private pure elemental subroutine crop (this, start_row, end_row, start_col, end_col) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: start_row integer, intent(in) :: end_row integer, intent(in) :: start_col integer, intent(in) :: end_col procedure, public :: resize private pure elemental subroutine resize (this, new_height, new_width) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: new_height integer, intent(in) :: new_width Source Code type format_pnm character ( 2 ) , private :: magic_number integer , private :: width integer , private :: height character (:), allocatable , private :: comment integer , private :: max_color integer ( ik ), dimension (:,:), allocatable :: pixels character ( 3 ) , private :: file_format character ( 6 ) , private :: encoding contains procedure :: set_format procedure , private :: set_file_format procedure , private :: set_magicnumber procedure , private :: set_width procedure , private :: set_height procedure , private :: set_comment procedure , private :: set_max_color procedure , private :: set_header procedure , private :: allocate_pixels procedure , private :: check_pixel_range procedure , private :: set_pixels procedure :: set_pnm procedure :: print_info procedure :: import_pnm procedure :: export_pnm procedure :: finalize => deallocate_pnm procedure :: negative procedure :: brighten procedure :: swap_channels procedure :: remove_channels procedure :: greyscale procedure :: rotate procedure :: flip_horizontal procedure :: flip_vertical procedure :: crop procedure :: resize end type format_pnm","tags":"","loc":"type/format_pnm.html"},{"title":"get_num_colors – ForImage","text":"private pure elemental function get_num_colors(this) result(num_colors) Type Bound format_lut Arguments Type Intent Optional Attributes Name class( format_lut ), intent(in) :: this Return Value integer Called by proc~~get_num_colors~~CalledByGraph proc~get_num_colors lut::format_lut%get_num_colors proc~export lut::format_lut%export proc~export->proc~get_num_colors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure elemental function get_num_colors ( this ) result ( num_colors ) class ( format_lut ), intent ( in ) :: this integer :: num_colors num_colors = this % num_colors end function get_num_colors","tags":"","loc":"proc/get_num_colors.html"},{"title":"get_dim_colors – ForImage","text":"private pure elemental function get_dim_colors(this) result(dim_colors) Type Bound format_lut Arguments Type Intent Optional Attributes Name class( format_lut ), intent(in) :: this Return Value integer Source Code pure elemental function get_dim_colors ( this ) result ( dim_colors ) class ( format_lut ), intent ( in ) :: this integer :: dim_colors dim_colors = this % dim_colors end function get_dim_colors","tags":"","loc":"proc/get_dim_colors.html"},{"title":"get_colors – ForImage","text":"private pure function get_colors(this) result(colors) Type Bound format_lut Arguments Type Intent Optional Attributes Name class( format_lut ), intent(in) :: this Return Value integer, dimension(:,:), allocatable Source Code pure function get_colors ( this ) result ( colors ) class ( format_lut ), intent ( in ) :: this integer , dimension (:,:), allocatable :: colors colors = this % colors end function get_colors","tags":"","loc":"proc/get_colors.html"},{"title":"allocate_colors – ForImage","text":"private pure elemental subroutine allocate_colors(this) Type Bound format_lut Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this Called by proc~~allocate_colors~~CalledByGraph proc~allocate_colors lut::format_lut%allocate_colors proc~import lut::format_lut%import proc~import->proc~allocate_colors proc~set lut::format_lut%set proc~set->proc~allocate_colors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure elemental subroutine allocate_colors ( this ) class ( format_lut ), intent ( inout ) :: this if ( allocated ( this % colors )) deallocate ( this % colors ) allocate ( this % colors ( this % num_colors , this % dim_colors )) end subroutine allocate_colors","tags":"","loc":"proc/allocate_colors.html"},{"title":"set – ForImage","text":"private pure subroutine set(this, num_colors, dim_colors, colors) Type Bound format_lut Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this integer, intent(in) :: num_colors integer, intent(in) :: dim_colors integer, intent(in), dimension(:,:) :: colors Calls proc~~set~~CallsGraph proc~set lut::format_lut%set proc~allocate_colors lut::format_lut%allocate_colors proc~set->proc~allocate_colors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine set ( this , num_colors , dim_colors , colors ) class ( format_lut ), intent ( inout ) :: this integer , intent ( in ) :: num_colors , dim_colors integer , dimension (:,:), intent ( in ) :: colors this % num_colors = num_colors this % dim_colors = dim_colors call this % allocate_colors () this % colors = colors end subroutine set","tags":"","loc":"proc/set.html"},{"title":"set_num_colors – ForImage","text":"private pure elemental subroutine set_num_colors(this, num_colors) Type Bound format_lut Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this integer, intent(in) :: num_colors Called by proc~~set_num_colors~~CalledByGraph proc~set_num_colors lut::format_lut%set_num_colors proc~import lut::format_lut%import proc~import->proc~set_num_colors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure elemental subroutine set_num_colors ( this , num_colors ) class ( format_lut ), intent ( inout ) :: this integer , intent ( in ) :: num_colors this % num_colors = num_colors end subroutine set_num_colors","tags":"","loc":"proc/set_num_colors.html"},{"title":"set_dim_colors – ForImage","text":"private pure elemental subroutine set_dim_colors(this, dim_colors) Type Bound format_lut Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this integer, intent(in) :: dim_colors Called by proc~~set_dim_colors~~CalledByGraph proc~set_dim_colors lut::format_lut%set_dim_colors proc~import lut::format_lut%import proc~import->proc~set_dim_colors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure elemental subroutine set_dim_colors ( this , dim_colors ) class ( format_lut ), intent ( inout ) :: this integer , intent ( in ) :: dim_colors this % dim_colors = dim_colors end subroutine set_dim_colors","tags":"","loc":"proc/set_dim_colors.html"},{"title":"set_colors – ForImage","text":"private pure subroutine set_colors(this, colors) Type Bound format_lut Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this integer, intent(in), dimension(:,:) :: colors Source Code pure subroutine set_colors ( this , colors ) class ( format_lut ), intent ( inout ) :: this integer , dimension (:,:), intent ( in ) :: colors this % colors = colors end subroutine set_colors","tags":"","loc":"proc/set_colors.html"},{"title":"deallocate_lut – ForImage","text":"private pure elemental subroutine deallocate_lut(this) Type Bound format_lut Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this Source Code pure elemental subroutine deallocate_lut ( this ) class ( format_lut ), intent ( inout ) :: this if ( allocated ( this % colors )) deallocate ( this % colors ) end subroutine deallocate_lut","tags":"","loc":"proc/deallocate_lut.html"},{"title":"import – ForImage","text":"private impure subroutine import(this, file_name, dim_colors) Type Bound format_lut Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this character(len=*), intent(in) :: file_name integer, intent(in) :: dim_colors Calls proc~~import~~CallsGraph proc~import lut::format_lut%import proc~allocate_colors lut::format_lut%allocate_colors proc~import->proc~allocate_colors proc~set_dim_colors lut::format_lut%set_dim_colors proc~import->proc~set_dim_colors proc~set_num_colors lut::format_lut%set_num_colors proc~import->proc~set_num_colors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine import ( this , file_name , dim_colors ) class ( format_lut ), intent ( inout ) :: this character ( * ), intent ( in ) :: file_name integer , intent ( in ) :: dim_colors integer , dimension ( 1 , dim_colors ) :: temp integer :: nunit , iostat , num_rows , i logical :: file_exists integer , dimension ( dim_colors ) :: buffer inquire ( file = file_name // '.lut' , exist = file_exists ) if ( file_exists ) then open ( newunit = nunit , file = file_name // '.lut' , status = 'old' , action = 'read' , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' num_rows = 0 do read ( nunit , * , iostat = iostat ) temp (:,:) if ( iostat /= 0 ) exit num_rows = num_rows + 1 end do call this % set_num_colors ( num_rows ) call this % set_dim_colors ( dim_colors ) call this % allocate_colors () rewind ( nunit ) do i = 1 , num_rows read ( nunit , * ) buffer this % colors ( i ,:) = buffer end do close ( nunit ) else error stop 'File ' // file_name // '.lut' // ' does not exist!' end if end subroutine import","tags":"","loc":"proc/import.html"},{"title":"export – ForImage","text":"private impure subroutine export(this, file_name) Type Bound format_lut Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this character(len=*), intent(in) :: file_name Calls proc~~export~~CallsGraph proc~export lut::format_lut%export proc~get_num_colors lut::format_lut%get_num_colors proc~export->proc~get_num_colors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine export ( this , file_name ) class ( format_lut ), intent ( inout ) :: this character ( * ), intent ( in ) :: file_name integer :: nunit , i integer , dimension ( this % dim_colors ) :: buffer integer :: iostat open ( newunit = nunit , file = file_name // '.lut' , status = 'replace' , action = 'write' , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' do i = 1 , this % get_num_colors () buffer = this % colors ( i ,:) write ( nunit , '(*(I3,1x))' ) buffer end do close ( nunit ) end subroutine export","tags":"","loc":"proc/export.html"},{"title":"mandelbrot – ForImage","text":"pure function mandelbrot(h, w) result(pixels) Arguments Type Intent Optional Attributes Name integer, intent(in) :: h integer, intent(in) :: w Return Value integer(kind=ik), (h,3*w) Called by proc~~mandelbrot~~CalledByGraph proc~mandelbrot demo::mandelbrot program~demo demo program~demo->proc~mandelbrot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mandelbrot.html"},{"title":"print_info – ForImage","text":"private impure elemental subroutine print_info(this) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(in) :: this Calls proc~~print_info~~CallsGraph proc~print_info pnm::format_pnm%print_info proc~aspect_ratio pnm::aspect_ratio proc~print_info->proc~aspect_ratio proc~average_colors pnm::average_colors proc~print_info->proc~average_colors proc~pixel_size pnm::pixel_size proc~print_info->proc~pixel_size Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_info~~CalledByGraph proc~print_info pnm::format_pnm%print_info program~demo demo program~demo->proc~print_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental impure subroutine print_info ( this ) class ( format_pnm ), intent ( in ) :: this real ( rk ) :: avg , avg_red , avg_green , avg_blue real ( rk ) :: asp_ratio real ( rk ) :: pixel_size_kb , pixel_size_mb select case ( this % file_format ) case ( 'pbm' , 'pgm' ) call average_colors ( this , avg ) case ( 'ppm' ) call average_colors ( this , avg , avg_red , avg_green , avg_blue ) end select call aspect_ratio ( this , asp_ratio ) call pixel_size ( this , pixel_size_kb , pixel_size_mb ) print '(a)' , 'Image Information:' print '(a)' , '-------------------------------------------' print '(a, g0)' , 'Magic Number: ' , this % magic_number print '(a, a)' , 'File Format : ' , this % file_format print '(a, a)' , 'Encoding    : ' , this % encoding print '(a, a)' , 'Comment     : ' , trim ( this % comment ) print '(a, a, g0, a, g0)' , 'Dimensions  : ' , 'Height: ' , this % height , ' Width: ' , this % width print '(a, g0)' , 'Total Pixels: ' , this % width * this % height print '(a, f6.2)' , 'Aspect Ratio: ' , asp_ratio print '(a, f8.2, a, f8.2, a)' , 'Pixel Size  : ' , pixel_size_kb , ' KB ' , pixel_size_mb , ' MB' select case ( this % file_format ) case ( 'pbm' , 'pgm' ) print '(a, g0)' , 'Average     : ' , avg case ( 'ppm' ) print '(a, g0)' , 'Max Color   : ' , this % max_color print '(a, a, f6.2, a, f6.2, a, f6.2)' , 'Average RGB : ' , 'R:' , avg_red , ' G:' , avg_green , ' B:' , avg_blue end select print '(a)' , '-------------------------------------------' end subroutine print_info","tags":"","loc":"proc/print_info.html"},{"title":"pixel_size – ForImage","text":"private pure elemental subroutine pixel_size(this, pixel_size_kb, pixel_size_mb) Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(in) :: this real(kind=rk), intent(out) :: pixel_size_kb real(kind=rk), intent(out) :: pixel_size_mb Called by proc~~pixel_size~~CalledByGraph proc~pixel_size pnm::pixel_size proc~print_info pnm::format_pnm%print_info proc~print_info->proc~pixel_size program~demo demo program~demo->proc~print_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine pixel_size ( this , pixel_size_kb , pixel_size_mb ) class ( format_pnm ), intent ( in ) :: this real ( rk ), intent ( out ) :: pixel_size_kb , pixel_size_mb integer :: bits_per_channel , bytes_per_pixel bits_per_channel = 8 select case ( this % file_format ) case ( 'pbm' , 'pgm' ) bytes_per_pixel = bits_per_channel case ( 'ppm' ) bytes_per_pixel = bits_per_channel * 3 end select pixel_size_kb = real ( this % width * this % height * bytes_per_pixel , kind = rk ) / 102 4.0_rk pixel_size_mb = pixel_size_kb / 102 4.0_rk end subroutine pixel_size","tags":"","loc":"proc/pixel_size.html"},{"title":"average_colors – ForImage","text":"private pure elemental subroutine average_colors(this, avg, avg_red, avg_green, avg_blue) Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(in) :: this real(kind=rk), intent(out), optional :: avg real(kind=rk), intent(out), optional :: avg_red real(kind=rk), intent(out), optional :: avg_green real(kind=rk), intent(out), optional :: avg_blue Called by proc~~average_colors~~CalledByGraph proc~average_colors pnm::average_colors proc~print_info pnm::format_pnm%print_info proc~print_info->proc~average_colors program~demo demo program~demo->proc~print_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine average_colors ( this , avg , avg_red , avg_green , avg_blue ) class ( format_pnm ), intent ( in ) :: this real ( rk ), intent ( out ), optional :: avg_red , avg_green , avg_blue , avg integer :: total_pixels integer :: i , j select case ( this % file_format ) case ( 'pbm' , 'pgm' ) avg = 0.0_rk total_pixels = this % width * this % height do i = 1 , this % height do j = 1 , this % width avg = avg + real ( this % pixels ( i , j ), kind = rk ) end do end do avg = avg / real ( total_pixels , kind = rk ) case ( 'ppm' ) avg_red = 0.0_rk avg_green = 0.0_rk avg_blue = 0.0_rk total_pixels = this % width * this % height do i = 1 , this % height do j = 1 , this % width avg_red = avg_red + real ( this % pixels ( i , 3 * j - 2 ), kind = rk ) avg_green = avg_green + real ( this % pixels ( i , 3 * j - 1 ), kind = rk ) avg_blue = avg_blue + real ( this % pixels ( i , 3 * j - 0 ), kind = rk ) end do end do avg_red = avg_red / real ( total_pixels , kind = rk ) avg_green = avg_green / real ( total_pixels , kind = rk ) avg_blue = avg_blue / real ( total_pixels , kind = rk ) end select end subroutine average_colors","tags":"","loc":"proc/average_colors.html"},{"title":"aspect_ratio – ForImage","text":"private pure elemental subroutine aspect_ratio(this, ratio) Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(in) :: this real(kind=rk), intent(out) :: ratio Called by proc~~aspect_ratio~~CalledByGraph proc~aspect_ratio pnm::aspect_ratio proc~print_info pnm::format_pnm%print_info proc~print_info->proc~aspect_ratio program~demo demo program~demo->proc~print_info Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine aspect_ratio ( this , ratio ) class ( format_pnm ), intent ( in ) :: this real ( rk ), intent ( out ) :: ratio ratio = real ( this % width , kind = rk ) / real ( this % height , kind = rk ) end subroutine aspect_ratio","tags":"","loc":"proc/aspect_ratio.html"},{"title":"resize – ForImage","text":"private pure elemental subroutine resize(this, new_height, new_width) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: new_height integer, intent(in) :: new_width Calls proc~~resize~~CallsGraph proc~resize pnm::format_pnm%resize proc~allocate_pixels pnm::format_pnm%allocate_pixels proc~resize->proc~allocate_pixels proc~set_height pnm::format_pnm%set_height proc~resize->proc~set_height proc~set_pixels pnm::format_pnm%set_pixels proc~resize->proc~set_pixels proc~set_width pnm::format_pnm%set_width proc~resize->proc~set_width proc~check_pixel_range pnm::format_pnm%check_pixel_range proc~set_pixels->proc~check_pixel_range Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~resize~~CalledByGraph proc~resize pnm::format_pnm%resize program~demo demo program~demo->proc~resize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine resize ( this , new_height , new_width ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: new_width , new_height integer ( ik ), dimension (:,:), allocatable :: resized_pixels integer :: i_out , j_out , i_in , j_in , channel real ( rk ) :: width_scale , height_scale select case ( this % file_format ) case ( 'pbm' , 'pgm' ) allocate ( resized_pixels ( new_height , new_width )) width_scale = real ( this % width , kind = rk ) / real ( new_width , kind = rk ) height_scale = real ( this % height , kind = rk ) / real ( new_height , kind = rk ) do i_out = 1 , new_height do j_out = 1 , new_width i_in = min ( this % height , max ( 1 , int (( real ( i_out , kind = rk ) - 0.5_rk ) * height_scale ) + 1 )) j_in = min ( this % width , max ( 1 , int (( real ( j_out , kind = rk ) - 0.5_rk ) * width_scale ) + 1 )) resized_pixels ( i_out , j_out ) = this % pixels ( i_in , j_in ) end do end do case ( 'ppm' ) allocate ( resized_pixels ( new_height , 3 * new_width )) width_scale = real ( this % width , kind = rk ) / real ( new_width , kind = rk ) height_scale = real ( this % height , kind = rk ) / real ( new_height , kind = rk ) do i_out = 1 , new_height do j_out = 1 , new_width i_in = min ( this % height , max ( 1 , int (( real ( i_out , kind = rk ) - 0.5_rk ) * height_scale ) + 1 )) j_in = min ( 3 * this % width , max ( 1 , int (( real ( j_out , kind = rk ) - 0.5_rk ) * width_scale ) + 1 )) do channel = 1 , 3 resized_pixels ( i_out , 3 * ( j_out - 1 ) + channel ) = this % pixels ( i_in , 3 * ( j_in - 1 ) + channel ) end do end do end do end select call this % set_height ( new_height ) call this % set_width ( new_width ) deallocate ( this % pixels ) call this % allocate_pixels () call this % set_pixels ( resized_pixels ) deallocate ( resized_pixels ) end subroutine resize","tags":"","loc":"proc/resize.html"},{"title":"crop – ForImage","text":"private pure elemental subroutine crop(this, start_row, end_row, start_col, end_col) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: start_row integer, intent(in) :: end_row integer, intent(in) :: start_col integer, intent(in) :: end_col Calls proc~~crop~~CallsGraph proc~crop pnm::format_pnm%crop proc~allocate_pixels pnm::format_pnm%allocate_pixels proc~crop->proc~allocate_pixels proc~set_height pnm::format_pnm%set_height proc~crop->proc~set_height proc~set_pixels pnm::format_pnm%set_pixels proc~crop->proc~set_pixels proc~set_width pnm::format_pnm%set_width proc~crop->proc~set_width proc~check_pixel_range pnm::format_pnm%check_pixel_range proc~set_pixels->proc~check_pixel_range Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~crop~~CalledByGraph proc~crop pnm::format_pnm%crop program~demo demo program~demo->proc~crop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine crop ( this , start_row , end_row , start_col , end_col ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: start_row , end_row , start_col , end_col integer :: cropped_start_row , cropped_end_row , cropped_start_col , cropped_end_col integer ( ik ), dimension (:,:), allocatable :: cropped_pixels integer :: i , j , cropped_height , cropped_width ! Check if the cropping coordinates are within the image boundaries cropped_start_row = max ( 1 , start_row ) cropped_end_row = min ( this % height , end_row ) cropped_start_col = max ( 1 , start_col ) cropped_end_col = min ( this % width , end_col ) ! Calculate the dimensions of the cropped image cropped_height = cropped_end_row - cropped_start_row + 1 cropped_width = cropped_end_col - cropped_start_col + 1 select case ( this % file_format ) case ( 'pbm' , 'pgm' ) ! Allocate memory for cropped image pixels allocate ( cropped_pixels ( cropped_height , cropped_width )) ! Copy the cropped pixels to the new array do i = 1 , cropped_height do j = 1 , cropped_width cropped_pixels ( i , j ) = this % pixels ( cropped_start_row - 1 + i , ( cropped_start_col - 1 ) + j ) end do end do case ( 'ppm' ) ! Allocate memory for cropped image pixels allocate ( cropped_pixels ( cropped_height , 3 * cropped_width )) ! Copy the cropped pixels to the new array do i = 1 , cropped_height do j = 1 , 3 * cropped_width cropped_pixels ( i , j ) = this % pixels ( cropped_start_row - 1 + i , ( cropped_start_col - 1 ) * 3 + j ) end do end do end select ! Update image dimensions and pixels call this % set_height ( cropped_height ) call this % set_width ( cropped_width ) deallocate ( this % pixels ) call this % allocate_pixels () call this % set_pixels ( cropped_pixels ) ! Deallocate temporary array deallocate ( cropped_pixels ) end subroutine crop","tags":"","loc":"proc/crop.html"},{"title":"flip_vertical – ForImage","text":"private pure elemental subroutine flip_vertical(this) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this Calls proc~~flip_vertical~~CallsGraph proc~flip_vertical pnm::format_pnm%flip_vertical proc~check_pixel_range pnm::format_pnm%check_pixel_range proc~flip_vertical->proc~check_pixel_range proc~set_height pnm::format_pnm%set_height proc~flip_vertical->proc~set_height proc~set_width pnm::format_pnm%set_width proc~flip_vertical->proc~set_width Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~flip_vertical~~CalledByGraph proc~flip_vertical pnm::format_pnm%flip_vertical program~demo demo program~demo->proc~flip_vertical Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine flip_vertical ( this ) class ( format_pnm ), intent ( inout ) :: this this % pixels = this % pixels ( size ( this % pixels , 1 ): 1 : - 1 , :) call this % check_pixel_range ( this % pixels ) call this % set_height ( size ( this % pixels , 1 )) select case ( this % file_format ) case ( 'pbm' , 'pgm' ) call this % set_width ( size ( this % pixels , 2 )) case ( 'ppm' ) call this % set_width ( size ( this % pixels , 2 ) / 3 ) end select end subroutine flip_vertical","tags":"","loc":"proc/flip_vertical.html"},{"title":"flip_horizontal – ForImage","text":"private pure elemental subroutine flip_horizontal(this) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this Calls proc~~flip_horizontal~~CallsGraph proc~flip_horizontal pnm::format_pnm%flip_horizontal proc~check_pixel_range pnm::format_pnm%check_pixel_range proc~flip_horizontal->proc~check_pixel_range proc~set_height pnm::format_pnm%set_height proc~flip_horizontal->proc~set_height proc~set_width pnm::format_pnm%set_width proc~flip_horizontal->proc~set_width Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~flip_horizontal~~CalledByGraph proc~flip_horizontal pnm::format_pnm%flip_horizontal program~demo demo program~demo->proc~flip_horizontal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine flip_horizontal ( this ) class ( format_pnm ), intent ( inout ) :: this select case ( this % file_format ) case ( 'pbm' , 'pgm' ) this % pixels = this % pixels (:, this % width : 1 : - 1 ) call this % check_pixel_range ( this % pixels ) case ( 'ppm' ) this % pixels (:, 1 : size ( this % pixels , 2 ): 3 ) = this % pixels (:, size ( this % pixels , 2 ) - 2 : 1 : - 3 ) this % pixels (:, 2 : size ( this % pixels , 2 ): 3 ) = this % pixels (:, size ( this % pixels , 2 ) - 1 : 2 : - 3 ) this % pixels (:, 3 : size ( this % pixels , 2 ): 3 ) = this % pixels (:, size ( this % pixels , 2 ) - 0 : 3 : - 3 ) call this % check_pixel_range ( this % pixels ) end select call this % set_height ( size ( this % pixels , 1 )) select case ( this % file_format ) case ( 'pbm' , 'pgm' ) call this % set_width ( size ( this % pixels , 2 )) case ( 'ppm' ) call this % set_width ( size ( this % pixels , 2 ) / 3 ) end select end subroutine flip_horizontal","tags":"","loc":"proc/flip_horizontal.html"},{"title":"rotate – ForImage","text":"private pure elemental subroutine rotate(this, angle) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: angle Calls proc~~rotate~~CallsGraph proc~rotate pnm::format_pnm%rotate proc~allocate_pixels pnm::format_pnm%allocate_pixels proc~rotate->proc~allocate_pixels proc~set_height pnm::format_pnm%set_height proc~rotate->proc~set_height proc~set_pixels pnm::format_pnm%set_pixels proc~rotate->proc~set_pixels proc~set_width pnm::format_pnm%set_width proc~rotate->proc~set_width proc~check_pixel_range pnm::format_pnm%check_pixel_range proc~set_pixels->proc~check_pixel_range Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rotate~~CalledByGraph proc~rotate pnm::format_pnm%rotate program~demo demo program~demo->proc~rotate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine rotate ( this , angle ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: angle integer ( ik ), dimension (:,:), allocatable :: rotated_pixels integer :: target_height , target_width integer :: i , j ! Determine the target height and width based on the rotation angle select case ( angle ) case ( 90 , - 90 , 270 , - 270 ) target_height = this % width target_width = this % height case ( 180 , - 180 ) target_height = this % height target_width = this % width case default error stop \"Invalid rotation angle. Valid angles are 90, 180, 270, -90, -180, -270.\" end select select case ( this % file_format ) case ( 'pbm' , 'pgm' ) ! Allocate memory for rotated_pixels array allocate ( rotated_pixels ( target_height , target_width )) ! Rotate pixels based on the specified angle select case ( angle ) case ( 90 , - 270 ) do i = 1 , this % height do j = 1 , this % width rotated_pixels ( j , this % height - i + 1 ) = this % pixels ( i , j ) end do end do case ( 180 , - 180 ) do i = 1 , this % height do j = 1 , this % width rotated_pixels ( this % height - i + 1 , this % width - j + 1 ) = this % pixels ( i , j ) end do end do case ( 270 , - 90 ) do i = 1 , this % height do j = 1 , this % width rotated_pixels ( this % width - j + 1 , i ) = this % pixels ( i , j ) end do end do end select case ( 'ppm' ) ! Allocate memory for rotated_pixels array allocate ( rotated_pixels ( target_height , 3 * target_width )) ! Rotate pixels based on the specified angle select case ( angle ) case ( 90 , - 270 ) do i = 1 , this % height do j = 1 , this % width rotated_pixels ( j , 3 * ( this % height - i + 1 ) - 2 : 3 * ( this % height - i + 1 )) = this % pixels ( i , 3 * j - 2 : 3 * j ) end do end do case ( 180 , - 180 ) do i = 1 , this % height do j = 1 , this % width rotated_pixels ( this % height - i + 1 , 3 * ( this % width - j + 1 ) - 2 : 3 * ( this % width - j + 1 )) = this % pixels ( i , 3 * j - 2 : 3 * j ) end do end do case ( 270 , - 90 ) do i = 1 , this % height do j = 1 , this % width rotated_pixels ( this % width - j + 1 , 3 * i - 2 : 3 * i ) = this % pixels ( i , 3 * j - 2 : 3 * j ) end do end do end select end select ! Update height and width of the image call this % set_height ( target_height ) call this % set_width ( target_width ) deallocate ( this % pixels ) call this % allocate_pixels () ! Update the original pixels with rotated pixels call this % set_pixels ( rotated_pixels ) ! Deallocate rotated_pixels array deallocate ( rotated_pixels ) end subroutine rotate","tags":"","loc":"proc/rotate.html"},{"title":"greyscale – ForImage","text":"private pure elemental subroutine greyscale(this) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this Calls proc~~greyscale~~CallsGraph proc~greyscale pnm::format_pnm%greyscale proc~check_pixel_range pnm::format_pnm%check_pixel_range proc~greyscale->proc~check_pixel_range Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~greyscale~~CalledByGraph proc~greyscale pnm::format_pnm%greyscale program~demo demo program~demo->proc~greyscale Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine greyscale ( this ) class ( format_pnm ), intent ( inout ) :: this real ( rk ) :: gsc integer :: i , j ! Check if the file is ppm if ( this % file_format /= 'ppm' ) error stop 'greyscale: This function is only for ppm files.' do i = 1 , this % height do j = 1 , this % width ! Calculate a weighed average (here based on ITU Rec.709) of the 3 channels to get a gray color with the same brightness. gsc = 0.2126_rk * real ( this % pixels ( i , 3 * j - 2 ), kind = rk ) + & 0.7152_rk * real ( this % pixels ( i , 3 * j - 1 ), kind = rk ) + & 0.0722_rk * real ( this % pixels ( i , 3 * j - 0 ), kind = rk ) ! Convert the greyscale value back to integer and set it for all RGB channels this % pixels ( i , 3 * j - 2 : 3 * j ) = int ( gsc ) end do end do call this % check_pixel_range ( this % pixels ) end subroutine greyscale","tags":"","loc":"proc/greyscale.html"},{"title":"remove_channels – ForImage","text":"private pure elemental subroutine remove_channels(this, remove_r, remove_g, remove_b) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this logical, intent(in), optional :: remove_r logical, intent(in), optional :: remove_g logical, intent(in), optional :: remove_b Calls proc~~remove_channels~~CallsGraph proc~remove_channels pnm::format_pnm%remove_channels proc~check_pixel_range pnm::format_pnm%check_pixel_range proc~remove_channels->proc~check_pixel_range Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~remove_channels~~CalledByGraph proc~remove_channels pnm::format_pnm%remove_channels program~demo demo program~demo->proc~remove_channels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine remove_channels ( this , remove_r , remove_g , remove_b ) class ( format_pnm ), intent ( inout ) :: this logical , optional , intent ( in ) :: remove_r , remove_g , remove_b ! Check if the file is ppm if ( this % file_format /= 'ppm' ) error stop 'remove_channels: This function is only for ppm files.' ! Remove R channel if ( present ( remove_r )) then if ( remove_r ) then this % pixels (:, 1 : size ( this % pixels , 2 ): 3 ) = 0 end if end if ! Remove G channel if ( present ( remove_g )) then if ( remove_g ) then this % pixels (:, 2 : size ( this % pixels , 2 ): 3 ) = 0 end if end if ! Remove B channel if ( present ( remove_b )) then if ( remove_b ) then this % pixels (:, 3 : size ( this % pixels , 2 ): 3 ) = 0 end if end if call this % check_pixel_range ( this % pixels ) end subroutine remove_channels","tags":"","loc":"proc/remove_channels.html"},{"title":"swap_channels – ForImage","text":"private pure elemental subroutine swap_channels(this, swap) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: swap Calls proc~~swap_channels~~CallsGraph proc~swap_channels pnm::format_pnm%swap_channels proc~check_pixel_range pnm::format_pnm%check_pixel_range proc~swap_channels->proc~check_pixel_range Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~swap_channels~~CalledByGraph proc~swap_channels pnm::format_pnm%swap_channels program~demo demo program~demo->proc~swap_channels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine swap_channels ( this , swap ) class ( format_pnm ), intent ( inout ) :: this character ( * ), intent ( in ) :: swap integer ( ik ) :: temp integer :: i , j ! Check if the file is ppm if ( this % file_format /= 'ppm' ) error stop 'swap_channels: This function is only for ppm files.' ! Swap R and G channels if ( swap == 'rg' . or . swap == 'gr' . or . swap == 'RG' . or . swap == 'GR' ) then do i = 1 , this % height do j = 1 , this % width temp = this % pixels ( i , 3 * j - 2 ) this % pixels ( i , 3 * j - 2 ) = this % pixels ( i , 3 * j - 1 ) this % pixels ( i , 3 * j - 1 ) = temp end do end do end if ! Swap G and B channels if ( swap == 'gb' . or . swap == 'bg' . or . swap == 'GB' . or . swap == 'BG' ) then do i = 1 , this % height do j = 1 , this % width temp = this % pixels ( i , 3 * j - 1 ) this % pixels ( i , 3 * j - 1 ) = this % pixels ( i , 3 * j - 0 ) this % pixels ( i , 3 * j - 0 ) = temp end do end do end if ! Swap R and B channels if ( swap == 'rb' . or . swap == 'br' . or . swap == 'RB' . or . swap == 'BR' ) then do i = 1 , this % height do j = 1 , this % width temp = this % pixels ( i , 3 * j - 2 ) this % pixels ( i , 3 * j - 2 ) = this % pixels ( i , 3 * j - 0 ) this % pixels ( i , 3 * j - 0 ) = temp end do end do end if call this % check_pixel_range ( this % pixels ) end subroutine swap_channels","tags":"","loc":"proc/swap_channels.html"},{"title":"brighten – ForImage","text":"private pure elemental subroutine brighten(this, factor) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: factor Calls proc~~brighten~~CallsGraph proc~brighten pnm::format_pnm%brighten proc~set_pixels pnm::format_pnm%set_pixels proc~brighten->proc~set_pixels proc~check_pixel_range pnm::format_pnm%check_pixel_range proc~set_pixels->proc~check_pixel_range Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~brighten~~CalledByGraph proc~brighten pnm::format_pnm%brighten program~demo demo program~demo->proc~brighten Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine brighten ( this , factor ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: factor select case ( this % file_format ) case ( 'pbm' ) error stop 'brighten: This function is not supported for pbm files.' case ( 'pgm' , 'ppm' ) call this % set_pixels ( min ( this % max_color , max ( 0 , this % pixels + factor ))) end select end subroutine brighten","tags":"","loc":"proc/brighten.html"},{"title":"negative – ForImage","text":"private pure elemental subroutine negative(this) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this Calls proc~~negative~~CallsGraph proc~negative pnm::format_pnm%negative proc~set_pixels pnm::format_pnm%set_pixels proc~negative->proc~set_pixels proc~check_pixel_range pnm::format_pnm%check_pixel_range proc~set_pixels->proc~check_pixel_range Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~negative~~CalledByGraph proc~negative pnm::format_pnm%negative program~demo demo program~demo->proc~negative Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine negative ( this ) class ( format_pnm ), intent ( inout ) :: this call this % set_pixels ( this % max_color - this % pixels ) end subroutine negative","tags":"","loc":"proc/negative.html"},{"title":"set_file_format – ForImage","text":"private pure elemental subroutine set_file_format(this, file_format) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=3), intent(in) :: file_format Called by proc~~set_file_format~~CalledByGraph proc~set_file_format pnm::format_pnm%set_file_format proc~import_pnm pnm::format_pnm%import_pnm proc~import_pnm->proc~set_file_format proc~set_pnm pnm::format_pnm%set_pnm proc~set_pnm->proc~set_file_format program~demo demo program~demo->proc~import_pnm program~demo->proc~set_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine set_file_format ( this , file_format ) class ( format_pnm ), intent ( inout ) :: this character ( 3 ), intent ( in ) :: file_format this % file_format = file_format end subroutine set_file_format","tags":"","loc":"proc/set_file_format.html"},{"title":"set_format – ForImage","text":"private pure elemental subroutine set_format(this, encoding) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: encoding Called by proc~~set_format~~CalledByGraph proc~set_format pnm::format_pnm%set_format proc~export_pnm pnm::format_pnm%export_pnm proc~export_pnm->proc~set_format proc~import_pnm pnm::format_pnm%import_pnm proc~import_pnm->proc~set_format proc~set_pnm pnm::format_pnm%set_pnm proc~set_pnm->proc~set_format program~demo demo program~demo->proc~export_pnm program~demo->proc~import_pnm program~demo->proc~set_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine set_format ( this , encoding ) class ( format_pnm ), intent ( inout ) :: this character ( * ), intent ( in ) :: encoding this % encoding = trim ( encoding ) end subroutine set_format","tags":"","loc":"proc/set_format.html"},{"title":"deallocate_pnm – ForImage","text":"private pure elemental subroutine deallocate_pnm(this) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this Called by proc~~deallocate_pnm~~CalledByGraph proc~deallocate_pnm pnm::format_pnm%deallocate_pnm program~demo demo program~demo->proc~deallocate_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine deallocate_pnm ( this ) class ( format_pnm ), intent ( inout ) :: this if ( allocated ( this % pixels )) deallocate ( this % pixels ) end subroutine deallocate_pnm","tags":"","loc":"proc/deallocate_pnm.html"},{"title":"import_pnm – ForImage","text":"private impure subroutine import_pnm(this, file_name, file_format, encoding) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: file_name character(len=3), intent(in) :: file_format character(len=*), intent(in) :: encoding Calls proc~~import_pnm~~CallsGraph proc~import_pnm pnm::format_pnm%import_pnm proc~allocate_pixels pnm::format_pnm%allocate_pixels proc~import_pnm->proc~allocate_pixels proc~check_pixel_range pnm::format_pnm%check_pixel_range proc~import_pnm->proc~check_pixel_range proc~read_header pnm::read_header proc~import_pnm->proc~read_header proc~set_file_format pnm::format_pnm%set_file_format proc~import_pnm->proc~set_file_format proc~set_format pnm::format_pnm%set_format proc~import_pnm->proc~set_format Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~import_pnm~~CalledByGraph proc~import_pnm pnm::format_pnm%import_pnm program~demo demo program~demo->proc~import_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine import_pnm ( this , file_name , file_format , encoding ) class ( format_pnm ), intent ( inout ) :: this character ( * ), intent ( in ) :: file_name , encoding character ( 3 ), intent ( in ) :: file_format integer :: nunit , i , j , iostat character , dimension (:), allocatable :: buffer_ch integer ( ik ), dimension (:), allocatable :: buffer_int logical :: file_exists inquire ( file = file_name // '.' // file_format , exist = file_exists ) if ( file_exists ) then call this % set_file_format ( file_format ) call this % set_format ( encoding ) select case ( this % encoding ) case ( 'binary' , 'raw' ) select case ( file_format ) case ( 'pbm' ) open ( newunit = nunit , file = file_name // '.' // file_format , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' call read_header ( this , nunit ) allocate ( buffer_ch ( this % height * this % width )) buffer_ch = achar ( 0_ik ) read ( nunit , '(*(a))' , advance = 'no' , iostat = iostat ) buffer_ch if ( iostat /= 0 ) error stop 'Error reading the file.' call this % allocate_pixels () this % pixels = iachar ( transpose ( reshape ( buffer_ch , [ this % width , this % height ])), kind = ik ) close ( nunit ) case ( 'pgm' ) open ( newunit = nunit , file = file_name // '.' // file_format , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' call read_header ( this , nunit ) allocate ( buffer_ch ( this % height * this % width )) buffer_ch = achar ( 0_ik ) read ( nunit , '(*(a))' , advance = 'no' , iostat = iostat ) buffer_ch if ( iostat /= 0 ) error stop 'Error reading the file.' call this % allocate_pixels () this % pixels = iachar ( transpose ( reshape ( buffer_ch , [ this % width , this % height ])), kind = ik ) close ( nunit ) case ( 'ppm' ) open ( newunit = nunit , file = file_name // '.' // file_format , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' call read_header ( this , nunit ) allocate ( buffer_ch ( this % height * 3 * this % width )) buffer_ch = achar ( 0_ik ) read ( nunit , '(*(a))' , advance = 'no' , iostat = iostat ) buffer_ch call this % allocate_pixels () this % pixels = iachar ( transpose ( reshape ( buffer_ch , [ this % width * 3 , this % height ])), kind = ik ) close ( nunit ) end select case ( 'ascii' , 'plain' ) select case ( file_format ) case ( 'pbm' ) open ( newunit = nunit , file = file_name // '.' // file_format , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' call read_header ( this , nunit ) allocate ( buffer_int ( this % height * this % width )) buffer_int = 0_ik read ( nunit , * ) buffer_int call this % allocate_pixels () this % pixels = transpose ( reshape ( buffer_int , [ this % width , this % height ])) close ( nunit ) call this % check_pixel_range ( this % pixels ) case ( 'pgm' ) open ( newunit = nunit , file = file_name // '.' // file_format , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' call read_header ( this , nunit ) allocate ( buffer_int ( this % height * this % width )) buffer_int = 0_ik read ( nunit , * ) buffer_int call this % allocate_pixels () this % pixels = transpose ( reshape ( buffer_int , [ this % width , this % height ])) call this % check_pixel_range ( this % pixels ) close ( nunit ) case ( 'ppm' ) open ( newunit = nunit , file = file_name // '.' // file_format , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' call read_header ( this , nunit ) allocate ( buffer_int ( this % height * 3 * this % width )) buffer_int = 0_ik read ( nunit , * ) buffer_int call this % allocate_pixels () this % pixels = transpose ( reshape ( buffer_int , [ this % width * 3 , this % height ])) call this % check_pixel_range ( this % pixels ) close ( nunit ) end select end select else error stop 'Error: File does not exist.' end if end subroutine import_pnm","tags":"","loc":"proc/import_pnm.html"},{"title":"set_pnm – ForImage","text":"private pure subroutine set_pnm(this, encoding, file_format, width, height, max_color, comment, pixels) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: encoding character(len=3), intent(in) :: file_format integer, intent(in) :: width integer, intent(in) :: height integer, intent(in), optional :: max_color character(len=*), intent(in) :: comment integer(kind=ik), intent(in), dimension(:,:) :: pixels Calls proc~~set_pnm~~CallsGraph proc~set_pnm pnm::format_pnm%set_pnm proc~allocate_pixels pnm::format_pnm%allocate_pixels proc~set_pnm->proc~allocate_pixels proc~set_file_format pnm::format_pnm%set_file_format proc~set_pnm->proc~set_file_format proc~set_format pnm::format_pnm%set_format proc~set_pnm->proc~set_format proc~set_header pnm::format_pnm%set_header proc~set_pnm->proc~set_header proc~set_pixels pnm::format_pnm%set_pixels proc~set_pnm->proc~set_pixels proc~set_comment pnm::format_pnm%set_comment proc~set_header->proc~set_comment proc~set_height pnm::format_pnm%set_height proc~set_header->proc~set_height proc~set_magicnumber pnm::format_pnm%set_magicnumber proc~set_header->proc~set_magicnumber proc~set_max_color pnm::format_pnm%set_max_color proc~set_header->proc~set_max_color proc~set_width pnm::format_pnm%set_width proc~set_header->proc~set_width proc~check_pixel_range pnm::format_pnm%check_pixel_range proc~set_pixels->proc~check_pixel_range Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_pnm~~CalledByGraph proc~set_pnm pnm::format_pnm%set_pnm program~demo demo program~demo->proc~set_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine set_pnm ( this , encoding , file_format , width , height , max_color , comment , pixels ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: width integer , intent ( in ) :: height character ( * ), intent ( in ) :: comment integer , optional , intent ( in ) :: max_color integer ( ik ), dimension (:,:), intent ( in ) :: pixels character ( * ), intent ( in ) :: encoding character ( 3 ), intent ( in ) :: file_format character ( 2 ) :: magic_number call this % set_format ( encoding ) call this % set_file_format ( file_format ) select case ( this % encoding ) case ( 'ascii' , 'plain' ) select case ( this % file_format ) case ( 'pbm' ) magic_number = 'P1' case ( 'pgm' ) magic_number = 'P2' case ( 'ppm' ) magic_number = 'P3' end select case ( 'binary' , 'raw' ) select case ( this % file_format ) case ( 'pbm' ) magic_number = 'P4' case ( 'pgm' ) magic_number = 'P5' case ( 'ppm' ) magic_number = 'P6' end select end select call this % set_header ( magic_number , width , height , comment , max_color ) call this % allocate_pixels () call this % set_pixels ( pixels ) end subroutine set_pnm","tags":"","loc":"proc/set_pnm.html"},{"title":"allocate_pixels – ForImage","text":"private pure elemental subroutine allocate_pixels(this) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this Called by proc~~allocate_pixels~~CalledByGraph proc~allocate_pixels pnm::format_pnm%allocate_pixels proc~crop pnm::format_pnm%crop proc~crop->proc~allocate_pixels proc~import_pnm pnm::format_pnm%import_pnm proc~import_pnm->proc~allocate_pixels proc~resize pnm::format_pnm%resize proc~resize->proc~allocate_pixels proc~rotate pnm::format_pnm%rotate proc~rotate->proc~allocate_pixels proc~set_pnm pnm::format_pnm%set_pnm proc~set_pnm->proc~allocate_pixels program~demo demo program~demo->proc~crop program~demo->proc~import_pnm program~demo->proc~resize program~demo->proc~rotate program~demo->proc~set_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine allocate_pixels ( this ) class ( format_pnm ), intent ( inout ) :: this select case ( this % magic_number ) case ( 'P1' ) if (. not . allocated ( this % pixels )) allocate ( this % pixels ( this % height , this % width )) case ( 'P2' ) if (. not . allocated ( this % pixels )) allocate ( this % pixels ( this % height , this % width )) case ( 'P3' ) if (. not . allocated ( this % pixels )) allocate ( this % pixels ( this % height , 3 * this % width )) case ( 'P4' ) if (. not . allocated ( this % pixels )) allocate ( this % pixels ( this % height , this % width )) case ( 'P5' ) if (. not . allocated ( this % pixels )) allocate ( this % pixels ( this % height , this % width )) case ( 'P6' ) if (. not . allocated ( this % pixels )) allocate ( this % pixels ( this % height , 3 * this % width )) end select end subroutine allocate_pixels","tags":"","loc":"proc/allocate_pixels.html"},{"title":"set_magicnumber – ForImage","text":"private pure elemental subroutine set_magicnumber(this, magic_number) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: magic_number Called by proc~~set_magicnumber~~CalledByGraph proc~set_magicnumber pnm::format_pnm%set_magicnumber proc~set_header pnm::format_pnm%set_header proc~set_header->proc~set_magicnumber proc~set_pnm pnm::format_pnm%set_pnm proc~set_pnm->proc~set_header program~demo demo program~demo->proc~set_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine set_magicnumber ( this , magic_number ) class ( format_pnm ), intent ( inout ) :: this character ( * ), intent ( in ) :: magic_number this % magic_number = magic_number end subroutine set_magicnumber","tags":"","loc":"proc/set_magicnumber.html"},{"title":"set_width – ForImage","text":"private pure elemental subroutine set_width(this, width) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: width Called by proc~~set_width~~CalledByGraph proc~set_width pnm::format_pnm%set_width proc~crop pnm::format_pnm%crop proc~crop->proc~set_width proc~flip_horizontal pnm::format_pnm%flip_horizontal proc~flip_horizontal->proc~set_width proc~flip_vertical pnm::format_pnm%flip_vertical proc~flip_vertical->proc~set_width proc~resize pnm::format_pnm%resize proc~resize->proc~set_width proc~rotate pnm::format_pnm%rotate proc~rotate->proc~set_width proc~set_header pnm::format_pnm%set_header proc~set_header->proc~set_width proc~set_pnm pnm::format_pnm%set_pnm proc~set_pnm->proc~set_header program~demo demo program~demo->proc~crop program~demo->proc~flip_horizontal program~demo->proc~flip_vertical program~demo->proc~resize program~demo->proc~rotate program~demo->proc~set_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine set_width ( this , width ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: width this % width = width end subroutine set_width","tags":"","loc":"proc/set_width.html"},{"title":"set_height – ForImage","text":"private pure elemental subroutine set_height(this, height) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: height Called by proc~~set_height~~CalledByGraph proc~set_height pnm::format_pnm%set_height proc~crop pnm::format_pnm%crop proc~crop->proc~set_height proc~flip_horizontal pnm::format_pnm%flip_horizontal proc~flip_horizontal->proc~set_height proc~flip_vertical pnm::format_pnm%flip_vertical proc~flip_vertical->proc~set_height proc~resize pnm::format_pnm%resize proc~resize->proc~set_height proc~rotate pnm::format_pnm%rotate proc~rotate->proc~set_height proc~set_header pnm::format_pnm%set_header proc~set_header->proc~set_height proc~set_pnm pnm::format_pnm%set_pnm proc~set_pnm->proc~set_header program~demo demo program~demo->proc~crop program~demo->proc~flip_horizontal program~demo->proc~flip_vertical program~demo->proc~resize program~demo->proc~rotate program~demo->proc~set_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine set_height ( this , height ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: height this % height = height end subroutine set_height","tags":"","loc":"proc/set_height.html"},{"title":"set_comment – ForImage","text":"private pure elemental subroutine set_comment(this, comment) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: comment Called by proc~~set_comment~~CalledByGraph proc~set_comment pnm::format_pnm%set_comment proc~set_header pnm::format_pnm%set_header proc~set_header->proc~set_comment proc~set_pnm pnm::format_pnm%set_pnm proc~set_pnm->proc~set_header program~demo demo program~demo->proc~set_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine set_comment ( this , comment ) class ( format_pnm ), intent ( inout ) :: this character ( * ), intent ( in ) :: comment this % comment = comment end subroutine set_comment","tags":"","loc":"proc/set_comment.html"},{"title":"set_max_color – ForImage","text":"private pure elemental subroutine set_max_color(this, max_color) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: max_color Called by proc~~set_max_color~~CalledByGraph proc~set_max_color pnm::format_pnm%set_max_color proc~set_header pnm::format_pnm%set_header proc~set_header->proc~set_max_color proc~set_pnm pnm::format_pnm%set_pnm proc~set_pnm->proc~set_header program~demo demo program~demo->proc~set_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine set_max_color ( this , max_color ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: max_color this % max_color = max_color end subroutine set_max_color","tags":"","loc":"proc/set_max_color.html"},{"title":"set_header – ForImage","text":"private pure elemental subroutine set_header(this, magic_number, width, height, comment, max_color) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: magic_number integer, intent(in) :: width integer, intent(in) :: height character(len=*), intent(in) :: comment integer, intent(in), optional :: max_color Calls proc~~set_header~~CallsGraph proc~set_header pnm::format_pnm%set_header proc~set_comment pnm::format_pnm%set_comment proc~set_header->proc~set_comment proc~set_height pnm::format_pnm%set_height proc~set_header->proc~set_height proc~set_magicnumber pnm::format_pnm%set_magicnumber proc~set_header->proc~set_magicnumber proc~set_max_color pnm::format_pnm%set_max_color proc~set_header->proc~set_max_color proc~set_width pnm::format_pnm%set_width proc~set_header->proc~set_width Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_header~~CalledByGraph proc~set_header pnm::format_pnm%set_header proc~set_pnm pnm::format_pnm%set_pnm proc~set_pnm->proc~set_header program~demo demo program~demo->proc~set_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine set_header ( this , magic_number , width , height , comment , max_color ) class ( format_pnm ), intent ( inout ) :: this character ( * ), intent ( in ) :: magic_number integer , intent ( in ) :: width integer , intent ( in ) :: height character ( * ), intent ( in ) :: comment integer , optional , intent ( in ) :: max_color call this % set_magicnumber ( magic_number ) call this % set_width ( width ) call this % set_height ( height ) call this % set_comment ( comment ) if ( this % file_format /= 'pbm' ) call this % set_max_color ( max_color ) end subroutine set_header","tags":"","loc":"proc/set_header.html"},{"title":"check_pixel_range – ForImage","text":"private pure subroutine check_pixel_range(this, pixels) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:,:) :: pixels Called by proc~~check_pixel_range~~CalledByGraph proc~check_pixel_range pnm::format_pnm%check_pixel_range proc~flip_horizontal pnm::format_pnm%flip_horizontal proc~flip_horizontal->proc~check_pixel_range proc~flip_vertical pnm::format_pnm%flip_vertical proc~flip_vertical->proc~check_pixel_range proc~greyscale pnm::format_pnm%greyscale proc~greyscale->proc~check_pixel_range proc~import_pnm pnm::format_pnm%import_pnm proc~import_pnm->proc~check_pixel_range proc~remove_channels pnm::format_pnm%remove_channels proc~remove_channels->proc~check_pixel_range proc~set_pixels pnm::format_pnm%set_pixels proc~set_pixels->proc~check_pixel_range proc~swap_channels pnm::format_pnm%swap_channels proc~swap_channels->proc~check_pixel_range proc~brighten pnm::format_pnm%brighten proc~brighten->proc~set_pixels proc~crop pnm::format_pnm%crop proc~crop->proc~set_pixels proc~negative pnm::format_pnm%negative proc~negative->proc~set_pixels proc~resize pnm::format_pnm%resize proc~resize->proc~set_pixels proc~rotate pnm::format_pnm%rotate proc~rotate->proc~set_pixels proc~set_pnm pnm::format_pnm%set_pnm proc~set_pnm->proc~set_pixels program~demo demo program~demo->proc~flip_horizontal program~demo->proc~flip_vertical program~demo->proc~greyscale program~demo->proc~import_pnm program~demo->proc~remove_channels program~demo->proc~swap_channels program~demo->proc~brighten program~demo->proc~crop program~demo->proc~negative program~demo->proc~resize program~demo->proc~rotate program~demo->proc~set_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine check_pixel_range ( this , pixels ) class ( format_pnm ), intent ( inout ) :: this integer ( ik ), dimension (:,:), intent ( in ) :: pixels ! Check if the pixel values are within the valid range select case ( this % file_format ) case ( 'pbm' ) if ( maxval ( pixels ) > 1 . or . minval ( pixels ) < 0 ) error stop 'set_pixels: Invalid pixel values.' case ( 'pgm' ) if ( maxval ( pixels ) > this % max_color . or . minval ( pixels ) < 0 ) error stop 'set_pixels: Invalid pixel values.' case ( 'ppm' ) if ( maxval ( pixels ) > this % max_color . or . minval ( pixels ) < 0 ) error stop 'set_pixels: Invalid pixel values.' end select end subroutine check_pixel_range","tags":"","loc":"proc/check_pixel_range.html"},{"title":"set_pixels – ForImage","text":"private pure subroutine set_pixels(this, pixels) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:,:) :: pixels Calls proc~~set_pixels~~CallsGraph proc~set_pixels pnm::format_pnm%set_pixels proc~check_pixel_range pnm::format_pnm%check_pixel_range proc~set_pixels->proc~check_pixel_range Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_pixels~~CalledByGraph proc~set_pixels pnm::format_pnm%set_pixels proc~brighten pnm::format_pnm%brighten proc~brighten->proc~set_pixels proc~crop pnm::format_pnm%crop proc~crop->proc~set_pixels proc~negative pnm::format_pnm%negative proc~negative->proc~set_pixels proc~resize pnm::format_pnm%resize proc~resize->proc~set_pixels proc~rotate pnm::format_pnm%rotate proc~rotate->proc~set_pixels proc~set_pnm pnm::format_pnm%set_pnm proc~set_pnm->proc~set_pixels program~demo demo program~demo->proc~brighten program~demo->proc~crop program~demo->proc~negative program~demo->proc~resize program~demo->proc~rotate program~demo->proc~set_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine set_pixels ( this , pixels ) class ( format_pnm ), intent ( inout ) :: this integer ( ik ), dimension (:,:), intent ( in ) :: pixels call this % check_pixel_range ( pixels ) this % pixels = pixels end subroutine set_pixels","tags":"","loc":"proc/set_pixels.html"},{"title":"set_pixel – ForImage","text":"private pure elemental subroutine set_pixel(this, grey, r, g, b, i, j) Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in), optional :: grey integer, intent(in), optional :: r integer, intent(in), optional :: g integer, intent(in), optional :: b integer, intent(in) :: i integer, intent(in) :: j Source Code elemental pure subroutine set_pixel ( this , grey , r , g , b , i , j ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ), optional :: grey integer , intent ( in ), optional :: r , g , b integer , intent ( in ) :: i , j select case ( this % magic_number ) case ( 'P1' ) this % pixels ( i , j ) = grey case ( 'P2' ) this % pixels ( i , j ) = grey case ( 'P3' ) this % pixels ( i , 3 * j - 2 ) = r this % pixels ( i , 3 * j - 1 ) = g this % pixels ( i , 3 * j - 0 ) = b end select end subroutine set_pixel","tags":"","loc":"proc/set_pixel.html"},{"title":"export_pnm – ForImage","text":"private impure subroutine export_pnm(this, file_name, encoding) Type Bound format_pnm Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: file_name character(len=*), intent(in), optional :: encoding Calls proc~~export_pnm~~CallsGraph proc~export_pnm pnm::format_pnm%export_pnm proc~set_format pnm::format_pnm%set_format proc~export_pnm->proc~set_format proc~write_header pnm::write_header proc~export_pnm->proc~write_header Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~export_pnm~~CalledByGraph proc~export_pnm pnm::format_pnm%export_pnm program~demo demo program~demo->proc~export_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine export_pnm ( this , file_name , encoding ) class ( format_pnm ), intent ( inout ) :: this character ( * ), intent ( in ) :: file_name character ( * ), intent ( in ), optional :: encoding integer :: nunit , i , j logical :: file_exists integer :: iostat if ( present ( encoding )) then call this % set_format ( encoding ) select case ( this % encoding ) case ( 'ascii' , 'plain' ) select case ( this % file_format ) case ( 'pbm' ) this % magic_number = 'P1' case ( 'pgm' ) this % magic_number = 'P2' case ( 'ppm' ) this % magic_number = 'P3' end select case ( 'binary' , 'raw' ) select case ( this % file_format ) case ( 'pbm' ) this % magic_number = 'P4' case ( 'pgm' ) this % magic_number = 'P5' case ( 'ppm' ) this % magic_number = 'P6' end select end select end if select case ( this % magic_number ) case ( 'P1' , 'P2' , 'P3' ) open ( newunit = nunit , file = file_name // '.' // this % file_format , status = 'replace' , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' call write_header ( this , nunit ) write ( nunit , '(*(g0,1x))' , advance = 'no' ) transpose ( this % pixels ) close ( nunit ) case ( 'P4' , 'P5' , 'P6' ) open ( newunit = nunit , file = file_name // '.' // this % file_format , status = 'replace' , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' call write_header ( this , nunit ) write ( nunit , '(*(a))' , advance = 'no' ) transpose ( achar ( this % pixels )) close ( nunit ) end select end subroutine export_pnm","tags":"","loc":"proc/export_pnm.html"},{"title":"write_header – ForImage","text":"private  subroutine write_header(this, nunit) Arguments Type Intent Optional Attributes Name type( format_pnm ), intent(in) :: this integer, intent(in) :: nunit Called by proc~~write_header~~CalledByGraph proc~write_header pnm::write_header proc~export_pnm pnm::format_pnm%export_pnm proc~export_pnm->proc~write_header program~demo demo program~demo->proc~export_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_header ( this , nunit ) type ( format_pnm ), intent ( in ) :: this integer , intent ( in ) :: nunit integer :: i , k ! Write magic number write ( nunit , '(a)' ) this % magic_number ! Write comments k = ceiling ( real ( len ( adjustl ( this % comment ))) / 7 0.0 ) if ( len ( adjustl ( this % comment )) /= 0 . and . len ( adjustl ( this % comment )) <= 70 ) then write ( nunit , '(a,a)' ) '# ' , trim ( adjustl ( this % comment )) else if ( len ( adjustl ( this % comment )) /= 0 . and . len ( adjustl ( this % comment )) > 70 ) then do i = 1 , k - 1 write ( nunit , '(a,a)' ) '# ' , adjustl ( this % comment ( 70 * ( i - 1 ) + 1 : 70 * ( i - 1 ) + 70 )) end do write ( nunit , '(a,a)' ) '# ' , trim ( adjustl ( this % comment ( 70 * ( k - 1 ) + 1 :))) end if ! Write width, height and max_color write ( nunit , '(g0,1x,g0)' ) this % width , this % height if ( this % file_format /= 'pbm' ) write ( nunit , '(g0)' ) this % max_color end subroutine write_header","tags":"","loc":"proc/write_header.html"},{"title":"read_header – ForImage","text":"private  subroutine read_header(this, nunit) Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: nunit Called by proc~~read_header~~CalledByGraph proc~read_header pnm::read_header proc~import_pnm pnm::format_pnm%import_pnm proc~import_pnm->proc~read_header program~demo demo program~demo->proc~import_pnm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine read_header ( this , nunit ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: nunit character ( len = 70 ) :: comment character :: temp integer :: i , k read ( nunit , * ) k = 0 do read ( nunit , '(a)' ) temp if ( temp /= '#' ) exit k = k + 1 end do rewind ( nunit ) read ( nunit , * ) this % magic_number this % comment = '' do i = 1 , k read ( nunit , '(a,a,a)' ) temp , temp , comment this % comment = this % comment // comment end do read ( nunit , * ) this % width , this % height if ( this % file_format == 'pgm' . or . this % file_format == 'ppm' ) read ( nunit , * ) this % max_color end subroutine read_header","tags":"","loc":"proc/read_header.html"},{"title":"lut – ForImage","text":"Used by module~~lut~~UsedByGraph module~lut lut module~forimage forimage module~forimage->module~lut program~demo demo program~demo->module~forimage Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: format_lut Components Type Visibility Attributes Name Initial integer, public :: num_colors integer, public :: dim_colors integer, public, dimension(:,:), allocatable :: colors Type-Bound Procedures procedure, public :: allocate_colors procedure, public :: set procedure, public :: set_num_colors procedure, public :: get_num_colors procedure, public :: set_dim_colors procedure, public :: get_dim_colors procedure, public :: set_colors procedure, public :: get_colors procedure, public :: export procedure, public :: import procedure, public :: finalize => deallocate_lut Functions private pure elemental function get_num_colors (this) result(num_colors) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(in) :: this Return Value integer private pure elemental function get_dim_colors (this) result(dim_colors) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(in) :: this Return Value integer private pure function get_colors (this) result(colors) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(in) :: this Return Value integer, dimension(:,:), allocatable Subroutines private pure elemental subroutine allocate_colors (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this private pure subroutine set (this, num_colors, dim_colors, colors) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this integer, intent(in) :: num_colors integer, intent(in) :: dim_colors integer, intent(in), dimension(:,:) :: colors private pure elemental subroutine set_num_colors (this, num_colors) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this integer, intent(in) :: num_colors private pure elemental subroutine set_dim_colors (this, dim_colors) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this integer, intent(in) :: dim_colors private pure subroutine set_colors (this, colors) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this integer, intent(in), dimension(:,:) :: colors private pure elemental subroutine deallocate_lut (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this private impure subroutine import (this, file_name, dim_colors) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this character(len=*), intent(in) :: file_name integer, intent(in) :: dim_colors private impure subroutine export (this, file_name) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_lut ), intent(inout) :: this character(len=*), intent(in) :: file_name","tags":"","loc":"module/lut.html"},{"title":"forimage_parameters – ForImage","text":"Uses iso_fortran_env module~~forimage_parameters~~UsesGraph module~forimage_parameters forimage_parameters iso_fortran_env iso_fortran_env module~forimage_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forimage_parameters~~UsedByGraph module~forimage_parameters forimage_parameters module~forimage forimage module~forimage->module~forimage_parameters module~pnm pnm module~forimage->module~pnm module~pnm->module~forimage_parameters program~demo demo program~demo->module~forimage Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=rk), public, parameter :: pi = 4.0_rk*atan(1.0_rk)","tags":"","loc":"module/forimage_parameters.html"},{"title":"forimage – ForImage","text":"Uses pnm lut forimage_parameters module~~forimage~~UsesGraph module~forimage forimage module~forimage_parameters forimage_parameters module~forimage->module~forimage_parameters module~lut lut module~forimage->module~lut module~pnm pnm module~forimage->module~pnm iso_fortran_env iso_fortran_env module~forimage_parameters->iso_fortran_env module~pnm->module~forimage_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forimage~~UsedByGraph module~forimage forimage program~demo demo program~demo->module~forimage Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module/forimage.html"},{"title":"pnm – ForImage","text":"Uses forimage_parameters module~~pnm~~UsesGraph module~pnm pnm module~forimage_parameters forimage_parameters module~pnm->module~forimage_parameters iso_fortran_env iso_fortran_env module~forimage_parameters->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pnm~~UsedByGraph module~pnm pnm module~forimage forimage module~forimage->module~pnm program~demo demo program~demo->module~forimage Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: format_pnm Components Type Visibility Attributes Name Initial character(len=2), private :: magic_number integer, private :: width integer, private :: height character(len=:), private, allocatable :: comment integer, private :: max_color integer(kind=ik), public, dimension(:,:), allocatable :: pixels character(len=3), private :: file_format character(len=6), private :: encoding Type-Bound Procedures procedure, public :: set_format procedure, private :: set_file_format procedure, private :: set_magicnumber procedure, private :: set_width procedure, private :: set_height procedure, private :: set_comment procedure, private :: set_max_color procedure, private :: set_header procedure, private :: allocate_pixels procedure, private :: check_pixel_range procedure, private :: set_pixels procedure, public :: set_pnm procedure, public :: print_info procedure, public :: import_pnm procedure, public :: export_pnm procedure, public :: finalize => deallocate_pnm procedure, public :: negative procedure, public :: brighten procedure, public :: swap_channels procedure, public :: remove_channels procedure, public :: greyscale procedure, public :: rotate procedure, public :: flip_horizontal procedure, public :: flip_vertical procedure, public :: crop procedure, public :: resize Subroutines private impure elemental subroutine print_info (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(in) :: this private pure elemental subroutine pixel_size (this, pixel_size_kb, pixel_size_mb) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(in) :: this real(kind=rk), intent(out) :: pixel_size_kb real(kind=rk), intent(out) :: pixel_size_mb private pure elemental subroutine average_colors (this, avg, avg_red, avg_green, avg_blue) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(in) :: this real(kind=rk), intent(out), optional :: avg real(kind=rk), intent(out), optional :: avg_red real(kind=rk), intent(out), optional :: avg_green real(kind=rk), intent(out), optional :: avg_blue private pure elemental subroutine aspect_ratio (this, ratio) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(in) :: this real(kind=rk), intent(out) :: ratio private pure elemental subroutine resize (this, new_height, new_width) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: new_height integer, intent(in) :: new_width private pure elemental subroutine crop (this, start_row, end_row, start_col, end_col) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: start_row integer, intent(in) :: end_row integer, intent(in) :: start_col integer, intent(in) :: end_col private pure elemental subroutine flip_vertical (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this private pure elemental subroutine flip_horizontal (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this private pure elemental subroutine rotate (this, angle) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: angle private pure elemental subroutine greyscale (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this private pure elemental subroutine remove_channels (this, remove_r, remove_g, remove_b) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this logical, intent(in), optional :: remove_r logical, intent(in), optional :: remove_g logical, intent(in), optional :: remove_b private pure elemental subroutine swap_channels (this, swap) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: swap private pure elemental subroutine brighten (this, factor) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: factor private pure elemental subroutine negative (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this private pure elemental subroutine set_file_format (this, file_format) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=3), intent(in) :: file_format private pure elemental subroutine set_format (this, encoding) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: encoding private pure elemental subroutine deallocate_pnm (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this private impure subroutine import_pnm (this, file_name, file_format, encoding) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: file_name character(len=3), intent(in) :: file_format character(len=*), intent(in) :: encoding private pure subroutine set_pnm (this, encoding, file_format, width, height, max_color, comment, pixels) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: encoding character(len=3), intent(in) :: file_format integer, intent(in) :: width integer, intent(in) :: height integer, intent(in), optional :: max_color character(len=*), intent(in) :: comment integer(kind=ik), intent(in), dimension(:,:) :: pixels private pure elemental subroutine allocate_pixels (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this private pure elemental subroutine set_magicnumber (this, magic_number) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: magic_number private pure elemental subroutine set_width (this, width) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: width private pure elemental subroutine set_height (this, height) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: height private pure elemental subroutine set_comment (this, comment) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: comment private pure elemental subroutine set_max_color (this, max_color) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: max_color private pure elemental subroutine set_header (this, magic_number, width, height, comment, max_color) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: magic_number integer, intent(in) :: width integer, intent(in) :: height character(len=*), intent(in) :: comment integer, intent(in), optional :: max_color private pure subroutine check_pixel_range (this, pixels) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:,:) :: pixels private pure subroutine set_pixels (this, pixels) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer(kind=ik), intent(in), dimension(:,:) :: pixels private pure elemental subroutine set_pixel (this, grey, r, g, b, i, j) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in), optional :: grey integer, intent(in), optional :: r integer, intent(in), optional :: g integer, intent(in), optional :: b integer, intent(in) :: i integer, intent(in) :: j private impure subroutine export_pnm (this, file_name, encoding) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this character(len=*), intent(in) :: file_name character(len=*), intent(in), optional :: encoding private  subroutine write_header (this, nunit) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name type( format_pnm ), intent(in) :: this integer, intent(in) :: nunit private  subroutine read_header (this, nunit) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( format_pnm ), intent(inout) :: this integer, intent(in) :: nunit","tags":"","loc":"module/pnm.html"},{"title":"demo – ForImage","text":"Uses forimage program~~demo~~UsesGraph program~demo demo module~forimage forimage program~demo->module~forimage module~forimage_parameters forimage_parameters module~forimage->module~forimage_parameters module~lut lut module~forimage->module~lut module~pnm pnm module~forimage->module~pnm iso_fortran_env iso_fortran_env module~forimage_parameters->iso_fortran_env module~pnm->module~forimage_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~demo~~CallsGraph program~demo demo proc~brighten pnm::format_pnm%brighten program~demo->proc~brighten proc~crop pnm::format_pnm%crop program~demo->proc~crop proc~deallocate_pnm pnm::format_pnm%deallocate_pnm program~demo->proc~deallocate_pnm proc~export_pnm pnm::format_pnm%export_pnm program~demo->proc~export_pnm proc~flip_horizontal pnm::format_pnm%flip_horizontal program~demo->proc~flip_horizontal proc~flip_vertical pnm::format_pnm%flip_vertical program~demo->proc~flip_vertical proc~greyscale pnm::format_pnm%greyscale program~demo->proc~greyscale proc~import_pnm pnm::format_pnm%import_pnm program~demo->proc~import_pnm proc~mandelbrot demo::mandelbrot program~demo->proc~mandelbrot proc~negative pnm::format_pnm%negative program~demo->proc~negative proc~print_info pnm::format_pnm%print_info program~demo->proc~print_info proc~remove_channels pnm::format_pnm%remove_channels program~demo->proc~remove_channels proc~resize pnm::format_pnm%resize program~demo->proc~resize proc~rotate pnm::format_pnm%rotate program~demo->proc~rotate proc~set_pnm pnm::format_pnm%set_pnm program~demo->proc~set_pnm proc~swap_channels pnm::format_pnm%swap_channels program~demo->proc~swap_channels proc~set_pixels pnm::format_pnm%set_pixels proc~brighten->proc~set_pixels proc~allocate_pixels pnm::format_pnm%allocate_pixels proc~crop->proc~allocate_pixels proc~set_height pnm::format_pnm%set_height proc~crop->proc~set_height proc~crop->proc~set_pixels proc~set_width pnm::format_pnm%set_width proc~crop->proc~set_width proc~set_format pnm::format_pnm%set_format proc~export_pnm->proc~set_format proc~write_header pnm::write_header proc~export_pnm->proc~write_header proc~check_pixel_range pnm::format_pnm%check_pixel_range proc~flip_horizontal->proc~check_pixel_range proc~flip_horizontal->proc~set_height proc~flip_horizontal->proc~set_width proc~flip_vertical->proc~check_pixel_range proc~flip_vertical->proc~set_height proc~flip_vertical->proc~set_width proc~greyscale->proc~check_pixel_range proc~import_pnm->proc~allocate_pixels proc~import_pnm->proc~check_pixel_range proc~read_header pnm::read_header proc~import_pnm->proc~read_header proc~set_file_format pnm::format_pnm%set_file_format proc~import_pnm->proc~set_file_format proc~import_pnm->proc~set_format proc~negative->proc~set_pixels proc~aspect_ratio pnm::aspect_ratio proc~print_info->proc~aspect_ratio proc~average_colors pnm::average_colors proc~print_info->proc~average_colors proc~pixel_size pnm::pixel_size proc~print_info->proc~pixel_size proc~remove_channels->proc~check_pixel_range proc~resize->proc~allocate_pixels proc~resize->proc~set_height proc~resize->proc~set_pixels proc~resize->proc~set_width proc~rotate->proc~allocate_pixels proc~rotate->proc~set_height proc~rotate->proc~set_pixels proc~rotate->proc~set_width proc~set_pnm->proc~allocate_pixels proc~set_pnm->proc~set_file_format proc~set_pnm->proc~set_format proc~set_header pnm::format_pnm%set_header proc~set_pnm->proc~set_header proc~set_pnm->proc~set_pixels proc~swap_channels->proc~check_pixel_range proc~set_header->proc~set_height proc~set_header->proc~set_width proc~set_comment pnm::format_pnm%set_comment proc~set_header->proc~set_comment proc~set_magicnumber pnm::format_pnm%set_magicnumber proc~set_header->proc~set_magicnumber proc~set_max_color pnm::format_pnm%set_max_color proc~set_header->proc~set_max_color proc~set_pixels->proc~check_pixel_range Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( format_pnm ) :: image type( format_pnm ) :: copy_image integer, parameter :: height = 400 integer, parameter :: width = 400 integer(kind=ik) :: px (height,3*width) Functions pure function mandelbrot (h, w) result(pixels) Arguments Type Intent Optional Attributes Name integer, intent(in) :: h integer, intent(in) :: w Return Value integer(kind=ik), (h,3*w) Source Code program demo use forimage , only : format_pnm , rk , ik implicit none ! Declare format_pnm object and parameters for image dimensions type ( format_pnm ) :: image , copy_image integer , parameter :: height = 400 integer , parameter :: width = 400 integer ( ik ) :: px ( height , 3 * width ) ! Generate Mandelbrot fractal and assign pixel values px = mandelbrot ( height , width ) ! Set the properties of the format_pnm object (encoding, file format, width, height, max_color, comment and pixels) call image % set_pnm (& encoding = 'binary' , & file_format = 'ppm' , & width = width , & height = height , & max_color = 255 , & comment = 'demo: mandelbrot' , & pixels = px & ) ! Print information about the image call image % print_info () ! Export the image to a PPM file call image % export_pnm ( 'pnm_files/mandelbrot_binary' ) ! Export the image to a PPM file with ascii encoding call image % export_pnm ( 'pnm_files/mandelbrot_ascii' , 'ascii' ) ! Export the image to a PPM file with a different encoding copy_image = image ! Copy the format_pnm object call copy_image % negative () call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_negative' , 'binary' ) call copy_image % finalize () ! Brighten the image copy_image = image ! Copy the format_pnm object call copy_image % brighten ( 100 ) call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_brighten' , 'binary' ) call copy_image % finalize () ! Swap the red and blue channels copy_image = image ! Copy the format_pnm object call copy_image % swap_channels ( 'rb' ) call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_swap' , 'binary' ) call copy_image % finalize () ! Remove the blue channel copy_image = image ! Copy the format_pnm object call copy_image % remove_channels ( remove_b = . true .) call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_remove' , 'binary' ) call copy_image % finalize () ! Convert the image to greyscale copy_image = image ! Copy the format_pnm object call copy_image % greyscale () call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_greyscale' , 'binary' ) call copy_image % finalize () ! Rotate the image 90 degrees clockwise copy_image = image ! Copy the format_pnm object call copy_image % rotate ( - 90 ) call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_rotate' , 'binary' ) call copy_image % finalize () ! Flip the image horizontally copy_image = image ! Copy the format_pnm object call copy_image % flip_horizontal () call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_flip_horizontal' , 'binary' ) call copy_image % finalize () ! Flip the image vertically copy_image = image ! Copy the format_pnm object call copy_image % flip_vertical () call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_flip_vertical' , 'binary' ) call copy_image % finalize () ! Crop the image copy_image = image ! Copy the format_pnm object call copy_image % crop ( 100 , 200 , 50 , 300 ) call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_crop' , 'binary' ) call copy_image % finalize () ! Resize the image copy_image = image ! Copy the format_pnm object call copy_image % resize ( 800 , 200 ) call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_resize' , 'binary' ) call copy_image % finalize () ! Finalize the format_pnm object to release resources call image % finalize () ! Import a PPM file with binary encoding and export it with ascii encoding call image % import_pnm ( 'pnm_files/mandelbrot_binary' , 'ppm' , 'binary' ) call image % export_pnm ( 'pnm_files/mandelbrot_ascii_ex' , 'ascii' ) call image % finalize () ! Import a PPM file with ascii encoding and export it with binary encoding call image % import_pnm ( 'pnm_files/mandelbrot_ascii' , 'ppm' , 'ascii' ) call image % export_pnm ( 'pnm_files/mandelbrot_binary_ex' , 'binary' ) call image % finalize () contains ! Function to generate Mandelbrot fractal pure function mandelbrot ( h , w ) result ( pixels ) integer , intent ( in ) :: w , h integer ( ik ) :: pixels ( h , 3 * w ) integer ( ik ), parameter :: max_iter = 256_ik real ( rk ), parameter :: x_min = - 2.0_rk real ( rk ), parameter :: x_max = 1.0_rk real ( rk ), parameter :: y_min = - 1.5_rk real ( rk ), parameter :: y_max = 1.5_rk real ( rk ) :: x , y , x_temp , zx , zy , zx2 , zy2 , scale_x , scale_y integer ( ik ) :: iter integer :: i , j ! Calculate scale factors for mapping pixel coordinates to Mandelbrot coordinates scale_x = ( x_max - x_min ) / real ( w , kind = rk ) scale_y = ( y_max - y_min ) / real ( h , kind = rk ) ! Generate Mandelbrot fractal do i = 1 , h do j = 1 , w x = x_min + real ( j - 1 , kind = rk ) * scale_x y = y_max - real ( i - 1 , kind = rk ) * scale_y zx = 0.0_rk zy = 0.0_rk iter = 0_ik do while ( iter < max_iter . and . zx * zx + zy * zy < 4.0_rk ) x_temp = zx * zx - zy * zy + x zy = 2.0_rk * zx * zy + y zx = x_temp iter = iter + 1_ik end do ! Assign colors pixels ( i , 3 * j - 2 ) = int ( mod ( iter * 7_ik , 256_ik ), kind = ik ) ! Red channel pixels ( i , 3 * j - 1 ) = int ( mod ( iter * 4_ik , 256_ik ), kind = ik ) ! Green channel pixels ( i , 3 * j ) = int ( mod ( iter * 10_ik , 256_ik ), kind = ik ) ! Blue channel end do end do end function end program demo","tags":"","loc":"program/demo.html"},{"title":"lut.f90 – ForImage","text":"Files dependent on this one sourcefile~~lut.f90~~AfferentGraph sourcefile~lut.f90 lut.f90 sourcefile~forimage.f90 forimage.f90 sourcefile~forimage.f90->sourcefile~lut.f90 sourcefile~demo.f90 demo.f90 sourcefile~demo.f90->sourcefile~forimage.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module lut implicit none private public format_lut !=============================================================================== type format_lut integer :: num_colors integer :: dim_colors integer , dimension (:,:), allocatable :: colors contains procedure :: allocate_colors procedure :: set procedure :: set_num_colors procedure :: get_num_colors procedure :: set_dim_colors procedure :: get_dim_colors procedure :: set_colors procedure :: get_colors procedure :: export procedure :: import procedure :: finalize => deallocate_lut end type format_lut !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi pure elemental subroutine allocate_colors ( this ) class ( format_lut ), intent ( inout ) :: this if ( allocated ( this % colors )) deallocate ( this % colors ) allocate ( this % colors ( this % num_colors , this % dim_colors )) end subroutine allocate_colors !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine set ( this , num_colors , dim_colors , colors ) class ( format_lut ), intent ( inout ) :: this integer , intent ( in ) :: num_colors , dim_colors integer , dimension (:,:), intent ( in ) :: colors this % num_colors = num_colors this % dim_colors = dim_colors call this % allocate_colors () this % colors = colors end subroutine set !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure elemental subroutine set_num_colors ( this , num_colors ) class ( format_lut ), intent ( inout ) :: this integer , intent ( in ) :: num_colors this % num_colors = num_colors end subroutine set_num_colors !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure elemental subroutine set_dim_colors ( this , dim_colors ) class ( format_lut ), intent ( inout ) :: this integer , intent ( in ) :: dim_colors this % dim_colors = dim_colors end subroutine set_dim_colors !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure elemental function get_num_colors ( this ) result ( num_colors ) class ( format_lut ), intent ( in ) :: this integer :: num_colors num_colors = this % num_colors end function get_num_colors !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure elemental function get_dim_colors ( this ) result ( dim_colors ) class ( format_lut ), intent ( in ) :: this integer :: dim_colors dim_colors = this % dim_colors end function get_dim_colors !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine set_colors ( this , colors ) class ( format_lut ), intent ( inout ) :: this integer , dimension (:,:), intent ( in ) :: colors this % colors = colors end subroutine set_colors !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure function get_colors ( this ) result ( colors ) class ( format_lut ), intent ( in ) :: this integer , dimension (:,:), allocatable :: colors colors = this % colors end function get_colors !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure elemental subroutine deallocate_lut ( this ) class ( format_lut ), intent ( inout ) :: this if ( allocated ( this % colors )) deallocate ( this % colors ) end subroutine deallocate_lut !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine import ( this , file_name , dim_colors ) class ( format_lut ), intent ( inout ) :: this character ( * ), intent ( in ) :: file_name integer , intent ( in ) :: dim_colors integer , dimension ( 1 , dim_colors ) :: temp integer :: nunit , iostat , num_rows , i logical :: file_exists integer , dimension ( dim_colors ) :: buffer inquire ( file = file_name // '.lut' , exist = file_exists ) if ( file_exists ) then open ( newunit = nunit , file = file_name // '.lut' , status = 'old' , action = 'read' , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' num_rows = 0 do read ( nunit , * , iostat = iostat ) temp (:,:) if ( iostat /= 0 ) exit num_rows = num_rows + 1 end do call this % set_num_colors ( num_rows ) call this % set_dim_colors ( dim_colors ) call this % allocate_colors () rewind ( nunit ) do i = 1 , num_rows read ( nunit , * ) buffer this % colors ( i ,:) = buffer end do close ( nunit ) else error stop 'File ' // file_name // '.lut' // ' does not exist!' end if end subroutine import !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine export ( this , file_name ) class ( format_lut ), intent ( inout ) :: this character ( * ), intent ( in ) :: file_name integer :: nunit , i integer , dimension ( this % dim_colors ) :: buffer integer :: iostat open ( newunit = nunit , file = file_name // '.lut' , status = 'replace' , action = 'write' , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' do i = 1 , this % get_num_colors () buffer = this % colors ( i ,:) write ( nunit , '(*(I3,1x))' ) buffer end do close ( nunit ) end subroutine export !=============================================================================== end module lut","tags":"","loc":"sourcefile/lut.f90.html"},{"title":"foimage_parameters.f90 – ForImage","text":"Files dependent on this one sourcefile~~foimage_parameters.f90~~AfferentGraph sourcefile~foimage_parameters.f90 foimage_parameters.f90 sourcefile~forimage.f90 forimage.f90 sourcefile~forimage.f90->sourcefile~foimage_parameters.f90 sourcefile~pnm.f90 pnm.f90 sourcefile~forimage.f90->sourcefile~pnm.f90 sourcefile~pnm.f90->sourcefile~foimage_parameters.f90 sourcefile~demo.f90 demo.f90 sourcefile~demo.f90->sourcefile~forimage.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forimage_parameters use iso_fortran_env , only : rk => real64 , ik => int32 implicit none private public :: rk , ik , pi real ( rk ), parameter :: pi = 4.0_rk * atan ( 1.0_rk ) end module forimage_parameters","tags":"","loc":"sourcefile/foimage_parameters.f90.html"},{"title":"forimage.f90 – ForImage","text":"This file depends on sourcefile~~forimage.f90~~EfferentGraph sourcefile~forimage.f90 forimage.f90 sourcefile~foimage_parameters.f90 foimage_parameters.f90 sourcefile~forimage.f90->sourcefile~foimage_parameters.f90 sourcefile~lut.f90 lut.f90 sourcefile~forimage.f90->sourcefile~lut.f90 sourcefile~pnm.f90 pnm.f90 sourcefile~forimage.f90->sourcefile~pnm.f90 sourcefile~pnm.f90->sourcefile~foimage_parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~forimage.f90~~AfferentGraph sourcefile~forimage.f90 forimage.f90 sourcefile~demo.f90 demo.f90 sourcefile~demo.f90->sourcefile~forimage.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forimage use forimage_parameters use pnm use lut private public format_pnm , format_lut , rk , ik , pi end module forimage","tags":"","loc":"sourcefile/forimage.f90.html"},{"title":"demo.f90 – ForImage","text":"This file depends on sourcefile~~demo.f90~~EfferentGraph sourcefile~demo.f90 demo.f90 sourcefile~forimage.f90 forimage.f90 sourcefile~demo.f90->sourcefile~forimage.f90 sourcefile~foimage_parameters.f90 foimage_parameters.f90 sourcefile~forimage.f90->sourcefile~foimage_parameters.f90 sourcefile~lut.f90 lut.f90 sourcefile~forimage.f90->sourcefile~lut.f90 sourcefile~pnm.f90 pnm.f90 sourcefile~forimage.f90->sourcefile~pnm.f90 sourcefile~pnm.f90->sourcefile~foimage_parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program demo use forimage , only : format_pnm , rk , ik implicit none ! Declare format_pnm object and parameters for image dimensions type ( format_pnm ) :: image , copy_image integer , parameter :: height = 400 integer , parameter :: width = 400 integer ( ik ) :: px ( height , 3 * width ) ! Generate Mandelbrot fractal and assign pixel values px = mandelbrot ( height , width ) ! Set the properties of the format_pnm object (encoding, file format, width, height, max_color, comment and pixels) call image % set_pnm (& encoding = 'binary' , & file_format = 'ppm' , & width = width , & height = height , & max_color = 255 , & comment = 'demo: mandelbrot' , & pixels = px & ) ! Print information about the image call image % print_info () ! Export the image to a PPM file call image % export_pnm ( 'pnm_files/mandelbrot_binary' ) ! Export the image to a PPM file with ascii encoding call image % export_pnm ( 'pnm_files/mandelbrot_ascii' , 'ascii' ) ! Export the image to a PPM file with a different encoding copy_image = image ! Copy the format_pnm object call copy_image % negative () call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_negative' , 'binary' ) call copy_image % finalize () ! Brighten the image copy_image = image ! Copy the format_pnm object call copy_image % brighten ( 100 ) call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_brighten' , 'binary' ) call copy_image % finalize () ! Swap the red and blue channels copy_image = image ! Copy the format_pnm object call copy_image % swap_channels ( 'rb' ) call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_swap' , 'binary' ) call copy_image % finalize () ! Remove the blue channel copy_image = image ! Copy the format_pnm object call copy_image % remove_channels ( remove_b = . true .) call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_remove' , 'binary' ) call copy_image % finalize () ! Convert the image to greyscale copy_image = image ! Copy the format_pnm object call copy_image % greyscale () call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_greyscale' , 'binary' ) call copy_image % finalize () ! Rotate the image 90 degrees clockwise copy_image = image ! Copy the format_pnm object call copy_image % rotate ( - 90 ) call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_rotate' , 'binary' ) call copy_image % finalize () ! Flip the image horizontally copy_image = image ! Copy the format_pnm object call copy_image % flip_horizontal () call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_flip_horizontal' , 'binary' ) call copy_image % finalize () ! Flip the image vertically copy_image = image ! Copy the format_pnm object call copy_image % flip_vertical () call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_flip_vertical' , 'binary' ) call copy_image % finalize () ! Crop the image copy_image = image ! Copy the format_pnm object call copy_image % crop ( 100 , 200 , 50 , 300 ) call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_crop' , 'binary' ) call copy_image % finalize () ! Resize the image copy_image = image ! Copy the format_pnm object call copy_image % resize ( 800 , 200 ) call copy_image % export_pnm ( 'pnm_files/mandelbrot_binary_resize' , 'binary' ) call copy_image % finalize () ! Finalize the format_pnm object to release resources call image % finalize () ! Import a PPM file with binary encoding and export it with ascii encoding call image % import_pnm ( 'pnm_files/mandelbrot_binary' , 'ppm' , 'binary' ) call image % export_pnm ( 'pnm_files/mandelbrot_ascii_ex' , 'ascii' ) call image % finalize () ! Import a PPM file with ascii encoding and export it with binary encoding call image % import_pnm ( 'pnm_files/mandelbrot_ascii' , 'ppm' , 'ascii' ) call image % export_pnm ( 'pnm_files/mandelbrot_binary_ex' , 'binary' ) call image % finalize () contains ! Function to generate Mandelbrot fractal pure function mandelbrot ( h , w ) result ( pixels ) integer , intent ( in ) :: w , h integer ( ik ) :: pixels ( h , 3 * w ) integer ( ik ), parameter :: max_iter = 256_ik real ( rk ), parameter :: x_min = - 2.0_rk real ( rk ), parameter :: x_max = 1.0_rk real ( rk ), parameter :: y_min = - 1.5_rk real ( rk ), parameter :: y_max = 1.5_rk real ( rk ) :: x , y , x_temp , zx , zy , zx2 , zy2 , scale_x , scale_y integer ( ik ) :: iter integer :: i , j ! Calculate scale factors for mapping pixel coordinates to Mandelbrot coordinates scale_x = ( x_max - x_min ) / real ( w , kind = rk ) scale_y = ( y_max - y_min ) / real ( h , kind = rk ) ! Generate Mandelbrot fractal do i = 1 , h do j = 1 , w x = x_min + real ( j - 1 , kind = rk ) * scale_x y = y_max - real ( i - 1 , kind = rk ) * scale_y zx = 0.0_rk zy = 0.0_rk iter = 0_ik do while ( iter < max_iter . and . zx * zx + zy * zy < 4.0_rk ) x_temp = zx * zx - zy * zy + x zy = 2.0_rk * zx * zy + y zx = x_temp iter = iter + 1_ik end do ! Assign colors pixels ( i , 3 * j - 2 ) = int ( mod ( iter * 7_ik , 256_ik ), kind = ik ) ! Red channel pixels ( i , 3 * j - 1 ) = int ( mod ( iter * 4_ik , 256_ik ), kind = ik ) ! Green channel pixels ( i , 3 * j ) = int ( mod ( iter * 10_ik , 256_ik ), kind = ik ) ! Blue channel end do end do end function end program demo","tags":"","loc":"sourcefile/demo.f90.html"},{"title":"pnm.f90 – ForImage","text":"This file depends on sourcefile~~pnm.f90~~EfferentGraph sourcefile~pnm.f90 pnm.f90 sourcefile~foimage_parameters.f90 foimage_parameters.f90 sourcefile~pnm.f90->sourcefile~foimage_parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pnm.f90~~AfferentGraph sourcefile~pnm.f90 pnm.f90 sourcefile~forimage.f90 forimage.f90 sourcefile~forimage.f90->sourcefile~pnm.f90 sourcefile~demo.f90 demo.f90 sourcefile~demo.f90->sourcefile~forimage.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module pnm use forimage_parameters , only : rk , ik implicit none private public format_pnm !=============================================================================== type format_pnm character ( 2 ) , private :: magic_number integer , private :: width integer , private :: height character (:), allocatable , private :: comment integer , private :: max_color integer ( ik ), dimension (:,:), allocatable :: pixels character ( 3 ) , private :: file_format character ( 6 ) , private :: encoding contains procedure :: set_format procedure , private :: set_file_format procedure , private :: set_magicnumber procedure , private :: set_width procedure , private :: set_height procedure , private :: set_comment procedure , private :: set_max_color procedure , private :: set_header procedure , private :: allocate_pixels procedure , private :: check_pixel_range procedure , private :: set_pixels procedure :: set_pnm procedure :: print_info procedure :: import_pnm procedure :: export_pnm procedure :: finalize => deallocate_pnm procedure :: negative procedure :: brighten procedure :: swap_channels procedure :: remove_channels procedure :: greyscale procedure :: rotate procedure :: flip_horizontal procedure :: flip_vertical procedure :: crop procedure :: resize end type format_pnm !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi elemental impure subroutine print_info ( this ) class ( format_pnm ), intent ( in ) :: this real ( rk ) :: avg , avg_red , avg_green , avg_blue real ( rk ) :: asp_ratio real ( rk ) :: pixel_size_kb , pixel_size_mb select case ( this % file_format ) case ( 'pbm' , 'pgm' ) call average_colors ( this , avg ) case ( 'ppm' ) call average_colors ( this , avg , avg_red , avg_green , avg_blue ) end select call aspect_ratio ( this , asp_ratio ) call pixel_size ( this , pixel_size_kb , pixel_size_mb ) print '(a)' , 'Image Information:' print '(a)' , '-------------------------------------------' print '(a, g0)' , 'Magic Number: ' , this % magic_number print '(a, a)' , 'File Format : ' , this % file_format print '(a, a)' , 'Encoding    : ' , this % encoding print '(a, a)' , 'Comment     : ' , trim ( this % comment ) print '(a, a, g0, a, g0)' , 'Dimensions  : ' , 'Height: ' , this % height , ' Width: ' , this % width print '(a, g0)' , 'Total Pixels: ' , this % width * this % height print '(a, f6.2)' , 'Aspect Ratio: ' , asp_ratio print '(a, f8.2, a, f8.2, a)' , 'Pixel Size  : ' , pixel_size_kb , ' KB ' , pixel_size_mb , ' MB' select case ( this % file_format ) case ( 'pbm' , 'pgm' ) print '(a, g0)' , 'Average     : ' , avg case ( 'ppm' ) print '(a, g0)' , 'Max Color   : ' , this % max_color print '(a, a, f6.2, a, f6.2, a, f6.2)' , 'Average RGB : ' , 'R:' , avg_red , ' G:' , avg_green , ' B:' , avg_blue end select print '(a)' , '-------------------------------------------' end subroutine print_info !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine pixel_size ( this , pixel_size_kb , pixel_size_mb ) class ( format_pnm ), intent ( in ) :: this real ( rk ), intent ( out ) :: pixel_size_kb , pixel_size_mb integer :: bits_per_channel , bytes_per_pixel bits_per_channel = 8 select case ( this % file_format ) case ( 'pbm' , 'pgm' ) bytes_per_pixel = bits_per_channel case ( 'ppm' ) bytes_per_pixel = bits_per_channel * 3 end select pixel_size_kb = real ( this % width * this % height * bytes_per_pixel , kind = rk ) / 102 4.0_rk pixel_size_mb = pixel_size_kb / 102 4.0_rk end subroutine pixel_size !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine average_colors ( this , avg , avg_red , avg_green , avg_blue ) class ( format_pnm ), intent ( in ) :: this real ( rk ), intent ( out ), optional :: avg_red , avg_green , avg_blue , avg integer :: total_pixels integer :: i , j select case ( this % file_format ) case ( 'pbm' , 'pgm' ) avg = 0.0_rk total_pixels = this % width * this % height do i = 1 , this % height do j = 1 , this % width avg = avg + real ( this % pixels ( i , j ), kind = rk ) end do end do avg = avg / real ( total_pixels , kind = rk ) case ( 'ppm' ) avg_red = 0.0_rk avg_green = 0.0_rk avg_blue = 0.0_rk total_pixels = this % width * this % height do i = 1 , this % height do j = 1 , this % width avg_red = avg_red + real ( this % pixels ( i , 3 * j - 2 ), kind = rk ) avg_green = avg_green + real ( this % pixels ( i , 3 * j - 1 ), kind = rk ) avg_blue = avg_blue + real ( this % pixels ( i , 3 * j - 0 ), kind = rk ) end do end do avg_red = avg_red / real ( total_pixels , kind = rk ) avg_green = avg_green / real ( total_pixels , kind = rk ) avg_blue = avg_blue / real ( total_pixels , kind = rk ) end select end subroutine average_colors !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine aspect_ratio ( this , ratio ) class ( format_pnm ), intent ( in ) :: this real ( rk ), intent ( out ) :: ratio ratio = real ( this % width , kind = rk ) / real ( this % height , kind = rk ) end subroutine aspect_ratio !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine resize ( this , new_height , new_width ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: new_width , new_height integer ( ik ), dimension (:,:), allocatable :: resized_pixels integer :: i_out , j_out , i_in , j_in , channel real ( rk ) :: width_scale , height_scale select case ( this % file_format ) case ( 'pbm' , 'pgm' ) allocate ( resized_pixels ( new_height , new_width )) width_scale = real ( this % width , kind = rk ) / real ( new_width , kind = rk ) height_scale = real ( this % height , kind = rk ) / real ( new_height , kind = rk ) do i_out = 1 , new_height do j_out = 1 , new_width i_in = min ( this % height , max ( 1 , int (( real ( i_out , kind = rk ) - 0.5_rk ) * height_scale ) + 1 )) j_in = min ( this % width , max ( 1 , int (( real ( j_out , kind = rk ) - 0.5_rk ) * width_scale ) + 1 )) resized_pixels ( i_out , j_out ) = this % pixels ( i_in , j_in ) end do end do case ( 'ppm' ) allocate ( resized_pixels ( new_height , 3 * new_width )) width_scale = real ( this % width , kind = rk ) / real ( new_width , kind = rk ) height_scale = real ( this % height , kind = rk ) / real ( new_height , kind = rk ) do i_out = 1 , new_height do j_out = 1 , new_width i_in = min ( this % height , max ( 1 , int (( real ( i_out , kind = rk ) - 0.5_rk ) * height_scale ) + 1 )) j_in = min ( 3 * this % width , max ( 1 , int (( real ( j_out , kind = rk ) - 0.5_rk ) * width_scale ) + 1 )) do channel = 1 , 3 resized_pixels ( i_out , 3 * ( j_out - 1 ) + channel ) = this % pixels ( i_in , 3 * ( j_in - 1 ) + channel ) end do end do end do end select call this % set_height ( new_height ) call this % set_width ( new_width ) deallocate ( this % pixels ) call this % allocate_pixels () call this % set_pixels ( resized_pixels ) deallocate ( resized_pixels ) end subroutine resize !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine crop ( this , start_row , end_row , start_col , end_col ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: start_row , end_row , start_col , end_col integer :: cropped_start_row , cropped_end_row , cropped_start_col , cropped_end_col integer ( ik ), dimension (:,:), allocatable :: cropped_pixels integer :: i , j , cropped_height , cropped_width ! Check if the cropping coordinates are within the image boundaries cropped_start_row = max ( 1 , start_row ) cropped_end_row = min ( this % height , end_row ) cropped_start_col = max ( 1 , start_col ) cropped_end_col = min ( this % width , end_col ) ! Calculate the dimensions of the cropped image cropped_height = cropped_end_row - cropped_start_row + 1 cropped_width = cropped_end_col - cropped_start_col + 1 select case ( this % file_format ) case ( 'pbm' , 'pgm' ) ! Allocate memory for cropped image pixels allocate ( cropped_pixels ( cropped_height , cropped_width )) ! Copy the cropped pixels to the new array do i = 1 , cropped_height do j = 1 , cropped_width cropped_pixels ( i , j ) = this % pixels ( cropped_start_row - 1 + i , ( cropped_start_col - 1 ) + j ) end do end do case ( 'ppm' ) ! Allocate memory for cropped image pixels allocate ( cropped_pixels ( cropped_height , 3 * cropped_width )) ! Copy the cropped pixels to the new array do i = 1 , cropped_height do j = 1 , 3 * cropped_width cropped_pixels ( i , j ) = this % pixels ( cropped_start_row - 1 + i , ( cropped_start_col - 1 ) * 3 + j ) end do end do end select ! Update image dimensions and pixels call this % set_height ( cropped_height ) call this % set_width ( cropped_width ) deallocate ( this % pixels ) call this % allocate_pixels () call this % set_pixels ( cropped_pixels ) ! Deallocate temporary array deallocate ( cropped_pixels ) end subroutine crop !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine flip_vertical ( this ) class ( format_pnm ), intent ( inout ) :: this this % pixels = this % pixels ( size ( this % pixels , 1 ): 1 : - 1 , :) call this % check_pixel_range ( this % pixels ) call this % set_height ( size ( this % pixels , 1 )) select case ( this % file_format ) case ( 'pbm' , 'pgm' ) call this % set_width ( size ( this % pixels , 2 )) case ( 'ppm' ) call this % set_width ( size ( this % pixels , 2 ) / 3 ) end select end subroutine flip_vertical !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine flip_horizontal ( this ) class ( format_pnm ), intent ( inout ) :: this select case ( this % file_format ) case ( 'pbm' , 'pgm' ) this % pixels = this % pixels (:, this % width : 1 : - 1 ) call this % check_pixel_range ( this % pixels ) case ( 'ppm' ) this % pixels (:, 1 : size ( this % pixels , 2 ): 3 ) = this % pixels (:, size ( this % pixels , 2 ) - 2 : 1 : - 3 ) this % pixels (:, 2 : size ( this % pixels , 2 ): 3 ) = this % pixels (:, size ( this % pixels , 2 ) - 1 : 2 : - 3 ) this % pixels (:, 3 : size ( this % pixels , 2 ): 3 ) = this % pixels (:, size ( this % pixels , 2 ) - 0 : 3 : - 3 ) call this % check_pixel_range ( this % pixels ) end select call this % set_height ( size ( this % pixels , 1 )) select case ( this % file_format ) case ( 'pbm' , 'pgm' ) call this % set_width ( size ( this % pixels , 2 )) case ( 'ppm' ) call this % set_width ( size ( this % pixels , 2 ) / 3 ) end select end subroutine flip_horizontal !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine rotate ( this , angle ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: angle integer ( ik ), dimension (:,:), allocatable :: rotated_pixels integer :: target_height , target_width integer :: i , j ! Determine the target height and width based on the rotation angle select case ( angle ) case ( 90 , - 90 , 270 , - 270 ) target_height = this % width target_width = this % height case ( 180 , - 180 ) target_height = this % height target_width = this % width case default error stop \"Invalid rotation angle. Valid angles are 90, 180, 270, -90, -180, -270.\" end select select case ( this % file_format ) case ( 'pbm' , 'pgm' ) ! Allocate memory for rotated_pixels array allocate ( rotated_pixels ( target_height , target_width )) ! Rotate pixels based on the specified angle select case ( angle ) case ( 90 , - 270 ) do i = 1 , this % height do j = 1 , this % width rotated_pixels ( j , this % height - i + 1 ) = this % pixels ( i , j ) end do end do case ( 180 , - 180 ) do i = 1 , this % height do j = 1 , this % width rotated_pixels ( this % height - i + 1 , this % width - j + 1 ) = this % pixels ( i , j ) end do end do case ( 270 , - 90 ) do i = 1 , this % height do j = 1 , this % width rotated_pixels ( this % width - j + 1 , i ) = this % pixels ( i , j ) end do end do end select case ( 'ppm' ) ! Allocate memory for rotated_pixels array allocate ( rotated_pixels ( target_height , 3 * target_width )) ! Rotate pixels based on the specified angle select case ( angle ) case ( 90 , - 270 ) do i = 1 , this % height do j = 1 , this % width rotated_pixels ( j , 3 * ( this % height - i + 1 ) - 2 : 3 * ( this % height - i + 1 )) = this % pixels ( i , 3 * j - 2 : 3 * j ) end do end do case ( 180 , - 180 ) do i = 1 , this % height do j = 1 , this % width rotated_pixels ( this % height - i + 1 , 3 * ( this % width - j + 1 ) - 2 : 3 * ( this % width - j + 1 )) = this % pixels ( i , 3 * j - 2 : 3 * j ) end do end do case ( 270 , - 90 ) do i = 1 , this % height do j = 1 , this % width rotated_pixels ( this % width - j + 1 , 3 * i - 2 : 3 * i ) = this % pixels ( i , 3 * j - 2 : 3 * j ) end do end do end select end select ! Update height and width of the image call this % set_height ( target_height ) call this % set_width ( target_width ) deallocate ( this % pixels ) call this % allocate_pixels () ! Update the original pixels with rotated pixels call this % set_pixels ( rotated_pixels ) ! Deallocate rotated_pixels array deallocate ( rotated_pixels ) end subroutine rotate !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine greyscale ( this ) class ( format_pnm ), intent ( inout ) :: this real ( rk ) :: gsc integer :: i , j ! Check if the file is ppm if ( this % file_format /= 'ppm' ) error stop 'greyscale: This function is only for ppm files.' do i = 1 , this % height do j = 1 , this % width ! Calculate a weighed average (here based on ITU Rec.709) of the 3 channels to get a gray color with the same brightness. gsc = 0.2126_rk * real ( this % pixels ( i , 3 * j - 2 ), kind = rk ) + & 0.7152_rk * real ( this % pixels ( i , 3 * j - 1 ), kind = rk ) + & 0.0722_rk * real ( this % pixels ( i , 3 * j - 0 ), kind = rk ) ! Convert the greyscale value back to integer and set it for all RGB channels this % pixels ( i , 3 * j - 2 : 3 * j ) = int ( gsc ) end do end do call this % check_pixel_range ( this % pixels ) end subroutine greyscale !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine remove_channels ( this , remove_r , remove_g , remove_b ) class ( format_pnm ), intent ( inout ) :: this logical , optional , intent ( in ) :: remove_r , remove_g , remove_b ! Check if the file is ppm if ( this % file_format /= 'ppm' ) error stop 'remove_channels: This function is only for ppm files.' ! Remove R channel if ( present ( remove_r )) then if ( remove_r ) then this % pixels (:, 1 : size ( this % pixels , 2 ): 3 ) = 0 end if end if ! Remove G channel if ( present ( remove_g )) then if ( remove_g ) then this % pixels (:, 2 : size ( this % pixels , 2 ): 3 ) = 0 end if end if ! Remove B channel if ( present ( remove_b )) then if ( remove_b ) then this % pixels (:, 3 : size ( this % pixels , 2 ): 3 ) = 0 end if end if call this % check_pixel_range ( this % pixels ) end subroutine remove_channels !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine swap_channels ( this , swap ) class ( format_pnm ), intent ( inout ) :: this character ( * ), intent ( in ) :: swap integer ( ik ) :: temp integer :: i , j ! Check if the file is ppm if ( this % file_format /= 'ppm' ) error stop 'swap_channels: This function is only for ppm files.' ! Swap R and G channels if ( swap == 'rg' . or . swap == 'gr' . or . swap == 'RG' . or . swap == 'GR' ) then do i = 1 , this % height do j = 1 , this % width temp = this % pixels ( i , 3 * j - 2 ) this % pixels ( i , 3 * j - 2 ) = this % pixels ( i , 3 * j - 1 ) this % pixels ( i , 3 * j - 1 ) = temp end do end do end if ! Swap G and B channels if ( swap == 'gb' . or . swap == 'bg' . or . swap == 'GB' . or . swap == 'BG' ) then do i = 1 , this % height do j = 1 , this % width temp = this % pixels ( i , 3 * j - 1 ) this % pixels ( i , 3 * j - 1 ) = this % pixels ( i , 3 * j - 0 ) this % pixels ( i , 3 * j - 0 ) = temp end do end do end if ! Swap R and B channels if ( swap == 'rb' . or . swap == 'br' . or . swap == 'RB' . or . swap == 'BR' ) then do i = 1 , this % height do j = 1 , this % width temp = this % pixels ( i , 3 * j - 2 ) this % pixels ( i , 3 * j - 2 ) = this % pixels ( i , 3 * j - 0 ) this % pixels ( i , 3 * j - 0 ) = temp end do end do end if call this % check_pixel_range ( this % pixels ) end subroutine swap_channels !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine brighten ( this , factor ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: factor select case ( this % file_format ) case ( 'pbm' ) error stop 'brighten: This function is not supported for pbm files.' case ( 'pgm' , 'ppm' ) call this % set_pixels ( min ( this % max_color , max ( 0 , this % pixels + factor ))) end select end subroutine brighten !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine negative ( this ) class ( format_pnm ), intent ( inout ) :: this call this % set_pixels ( this % max_color - this % pixels ) end subroutine negative !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine set_file_format ( this , file_format ) class ( format_pnm ), intent ( inout ) :: this character ( 3 ), intent ( in ) :: file_format this % file_format = file_format end subroutine set_file_format !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine set_format ( this , encoding ) class ( format_pnm ), intent ( inout ) :: this character ( * ), intent ( in ) :: encoding this % encoding = trim ( encoding ) end subroutine set_format !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine deallocate_pnm ( this ) class ( format_pnm ), intent ( inout ) :: this if ( allocated ( this % pixels )) deallocate ( this % pixels ) end subroutine deallocate_pnm !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine import_pnm ( this , file_name , file_format , encoding ) class ( format_pnm ), intent ( inout ) :: this character ( * ), intent ( in ) :: file_name , encoding character ( 3 ), intent ( in ) :: file_format integer :: nunit , i , j , iostat character , dimension (:), allocatable :: buffer_ch integer ( ik ), dimension (:), allocatable :: buffer_int logical :: file_exists inquire ( file = file_name // '.' // file_format , exist = file_exists ) if ( file_exists ) then call this % set_file_format ( file_format ) call this % set_format ( encoding ) select case ( this % encoding ) case ( 'binary' , 'raw' ) select case ( file_format ) case ( 'pbm' ) open ( newunit = nunit , file = file_name // '.' // file_format , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' call read_header ( this , nunit ) allocate ( buffer_ch ( this % height * this % width )) buffer_ch = achar ( 0_ik ) read ( nunit , '(*(a))' , advance = 'no' , iostat = iostat ) buffer_ch if ( iostat /= 0 ) error stop 'Error reading the file.' call this % allocate_pixels () this % pixels = iachar ( transpose ( reshape ( buffer_ch , [ this % width , this % height ])), kind = ik ) close ( nunit ) case ( 'pgm' ) open ( newunit = nunit , file = file_name // '.' // file_format , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' call read_header ( this , nunit ) allocate ( buffer_ch ( this % height * this % width )) buffer_ch = achar ( 0_ik ) read ( nunit , '(*(a))' , advance = 'no' , iostat = iostat ) buffer_ch if ( iostat /= 0 ) error stop 'Error reading the file.' call this % allocate_pixels () this % pixels = iachar ( transpose ( reshape ( buffer_ch , [ this % width , this % height ])), kind = ik ) close ( nunit ) case ( 'ppm' ) open ( newunit = nunit , file = file_name // '.' // file_format , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' call read_header ( this , nunit ) allocate ( buffer_ch ( this % height * 3 * this % width )) buffer_ch = achar ( 0_ik ) read ( nunit , '(*(a))' , advance = 'no' , iostat = iostat ) buffer_ch call this % allocate_pixels () this % pixels = iachar ( transpose ( reshape ( buffer_ch , [ this % width * 3 , this % height ])), kind = ik ) close ( nunit ) end select case ( 'ascii' , 'plain' ) select case ( file_format ) case ( 'pbm' ) open ( newunit = nunit , file = file_name // '.' // file_format , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' call read_header ( this , nunit ) allocate ( buffer_int ( this % height * this % width )) buffer_int = 0_ik read ( nunit , * ) buffer_int call this % allocate_pixels () this % pixels = transpose ( reshape ( buffer_int , [ this % width , this % height ])) close ( nunit ) call this % check_pixel_range ( this % pixels ) case ( 'pgm' ) open ( newunit = nunit , file = file_name // '.' // file_format , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' call read_header ( this , nunit ) allocate ( buffer_int ( this % height * this % width )) buffer_int = 0_ik read ( nunit , * ) buffer_int call this % allocate_pixels () this % pixels = transpose ( reshape ( buffer_int , [ this % width , this % height ])) call this % check_pixel_range ( this % pixels ) close ( nunit ) case ( 'ppm' ) open ( newunit = nunit , file = file_name // '.' // file_format , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' call read_header ( this , nunit ) allocate ( buffer_int ( this % height * 3 * this % width )) buffer_int = 0_ik read ( nunit , * ) buffer_int call this % allocate_pixels () this % pixels = transpose ( reshape ( buffer_int , [ this % width * 3 , this % height ])) call this % check_pixel_range ( this % pixels ) close ( nunit ) end select end select else error stop 'Error: File does not exist.' end if end subroutine import_pnm !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine set_pnm ( this , encoding , file_format , width , height , max_color , comment , pixels ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: width integer , intent ( in ) :: height character ( * ), intent ( in ) :: comment integer , optional , intent ( in ) :: max_color integer ( ik ), dimension (:,:), intent ( in ) :: pixels character ( * ), intent ( in ) :: encoding character ( 3 ), intent ( in ) :: file_format character ( 2 ) :: magic_number call this % set_format ( encoding ) call this % set_file_format ( file_format ) select case ( this % encoding ) case ( 'ascii' , 'plain' ) select case ( this % file_format ) case ( 'pbm' ) magic_number = 'P1' case ( 'pgm' ) magic_number = 'P2' case ( 'ppm' ) magic_number = 'P3' end select case ( 'binary' , 'raw' ) select case ( this % file_format ) case ( 'pbm' ) magic_number = 'P4' case ( 'pgm' ) magic_number = 'P5' case ( 'ppm' ) magic_number = 'P6' end select end select call this % set_header ( magic_number , width , height , comment , max_color ) call this % allocate_pixels () call this % set_pixels ( pixels ) end subroutine set_pnm !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine allocate_pixels ( this ) class ( format_pnm ), intent ( inout ) :: this select case ( this % magic_number ) case ( 'P1' ) if (. not . allocated ( this % pixels )) allocate ( this % pixels ( this % height , this % width )) case ( 'P2' ) if (. not . allocated ( this % pixels )) allocate ( this % pixels ( this % height , this % width )) case ( 'P3' ) if (. not . allocated ( this % pixels )) allocate ( this % pixels ( this % height , 3 * this % width )) case ( 'P4' ) if (. not . allocated ( this % pixels )) allocate ( this % pixels ( this % height , this % width )) case ( 'P5' ) if (. not . allocated ( this % pixels )) allocate ( this % pixels ( this % height , this % width )) case ( 'P6' ) if (. not . allocated ( this % pixels )) allocate ( this % pixels ( this % height , 3 * this % width )) end select end subroutine allocate_pixels !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine set_magicnumber ( this , magic_number ) class ( format_pnm ), intent ( inout ) :: this character ( * ), intent ( in ) :: magic_number this % magic_number = magic_number end subroutine set_magicnumber !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine set_width ( this , width ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: width this % width = width end subroutine set_width !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine set_height ( this , height ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: height this % height = height end subroutine set_height !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine set_comment ( this , comment ) class ( format_pnm ), intent ( inout ) :: this character ( * ), intent ( in ) :: comment this % comment = comment end subroutine set_comment !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine set_max_color ( this , max_color ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: max_color this % max_color = max_color end subroutine set_max_color !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine set_header ( this , magic_number , width , height , comment , max_color ) class ( format_pnm ), intent ( inout ) :: this character ( * ), intent ( in ) :: magic_number integer , intent ( in ) :: width integer , intent ( in ) :: height character ( * ), intent ( in ) :: comment integer , optional , intent ( in ) :: max_color call this % set_magicnumber ( magic_number ) call this % set_width ( width ) call this % set_height ( height ) call this % set_comment ( comment ) if ( this % file_format /= 'pbm' ) call this % set_max_color ( max_color ) end subroutine set_header !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine check_pixel_range ( this , pixels ) class ( format_pnm ), intent ( inout ) :: this integer ( ik ), dimension (:,:), intent ( in ) :: pixels ! Check if the pixel values are within the valid range select case ( this % file_format ) case ( 'pbm' ) if ( maxval ( pixels ) > 1 . or . minval ( pixels ) < 0 ) error stop 'set_pixels: Invalid pixel values.' case ( 'pgm' ) if ( maxval ( pixels ) > this % max_color . or . minval ( pixels ) < 0 ) error stop 'set_pixels: Invalid pixel values.' case ( 'ppm' ) if ( maxval ( pixels ) > this % max_color . or . minval ( pixels ) < 0 ) error stop 'set_pixels: Invalid pixel values.' end select end subroutine check_pixel_range !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine set_pixels ( this , pixels ) class ( format_pnm ), intent ( inout ) :: this integer ( ik ), dimension (:,:), intent ( in ) :: pixels call this % check_pixel_range ( pixels ) this % pixels = pixels end subroutine set_pixels !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine set_pixel ( this , grey , r , g , b , i , j ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ), optional :: grey integer , intent ( in ), optional :: r , g , b integer , intent ( in ) :: i , j select case ( this % magic_number ) case ( 'P1' ) this % pixels ( i , j ) = grey case ( 'P2' ) this % pixels ( i , j ) = grey case ( 'P3' ) this % pixels ( i , 3 * j - 2 ) = r this % pixels ( i , 3 * j - 1 ) = g this % pixels ( i , 3 * j - 0 ) = b end select end subroutine set_pixel !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine export_pnm ( this , file_name , encoding ) class ( format_pnm ), intent ( inout ) :: this character ( * ), intent ( in ) :: file_name character ( * ), intent ( in ), optional :: encoding integer :: nunit , i , j logical :: file_exists integer :: iostat if ( present ( encoding )) then call this % set_format ( encoding ) select case ( this % encoding ) case ( 'ascii' , 'plain' ) select case ( this % file_format ) case ( 'pbm' ) this % magic_number = 'P1' case ( 'pgm' ) this % magic_number = 'P2' case ( 'ppm' ) this % magic_number = 'P3' end select case ( 'binary' , 'raw' ) select case ( this % file_format ) case ( 'pbm' ) this % magic_number = 'P4' case ( 'pgm' ) this % magic_number = 'P5' case ( 'ppm' ) this % magic_number = 'P6' end select end select end if select case ( this % magic_number ) case ( 'P1' , 'P2' , 'P3' ) open ( newunit = nunit , file = file_name // '.' // this % file_format , status = 'replace' , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' call write_header ( this , nunit ) write ( nunit , '(*(g0,1x))' , advance = 'no' ) transpose ( this % pixels ) close ( nunit ) case ( 'P4' , 'P5' , 'P6' ) open ( newunit = nunit , file = file_name // '.' // this % file_format , status = 'replace' , iostat = iostat ) if ( iostat /= 0 ) error stop 'Error opening the file.' call write_header ( this , nunit ) write ( nunit , '(*(a))' , advance = 'no' ) transpose ( achar ( this % pixels )) close ( nunit ) end select end subroutine export_pnm !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine write_header ( this , nunit ) type ( format_pnm ), intent ( in ) :: this integer , intent ( in ) :: nunit integer :: i , k ! Write magic number write ( nunit , '(a)' ) this % magic_number ! Write comments k = ceiling ( real ( len ( adjustl ( this % comment ))) / 7 0.0 ) if ( len ( adjustl ( this % comment )) /= 0 . and . len ( adjustl ( this % comment )) <= 70 ) then write ( nunit , '(a,a)' ) '# ' , trim ( adjustl ( this % comment )) else if ( len ( adjustl ( this % comment )) /= 0 . and . len ( adjustl ( this % comment )) > 70 ) then do i = 1 , k - 1 write ( nunit , '(a,a)' ) '# ' , adjustl ( this % comment ( 70 * ( i - 1 ) + 1 : 70 * ( i - 1 ) + 70 )) end do write ( nunit , '(a,a)' ) '# ' , trim ( adjustl ( this % comment ( 70 * ( k - 1 ) + 1 :))) end if ! Write width, height and max_color write ( nunit , '(g0,1x,g0)' ) this % width , this % height if ( this % file_format /= 'pbm' ) write ( nunit , '(g0)' ) this % max_color end subroutine write_header !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine read_header ( this , nunit ) class ( format_pnm ), intent ( inout ) :: this integer , intent ( in ) :: nunit character ( len = 70 ) :: comment character :: temp integer :: i , k read ( nunit , * ) k = 0 do read ( nunit , '(a)' ) temp if ( temp /= '#' ) exit k = k + 1 end do rewind ( nunit ) read ( nunit , * ) this % magic_number this % comment = '' do i = 1 , k read ( nunit , '(a,a,a)' ) temp , temp , comment this % comment = this % comment // comment end do read ( nunit , * ) this % width , this % height if ( this % file_format == 'pgm' . or . this % file_format == 'ppm' ) read ( nunit , * ) this % max_color end subroutine read_header !=============================================================================== end module pnm","tags":"","loc":"sourcefile/pnm.f90.html"}]}